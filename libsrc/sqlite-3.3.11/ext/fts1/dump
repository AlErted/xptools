? dump
1.1          (drh      22-Aug-06): This folder contains source code to the first full-text search
1.1          (drh      22-Aug-06): extension for SQLite.
1.1          (drh      31-Aug-06): /* The author disclaims copyright to this source code.
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * This is an SQLite module implementing full-text search.
1.1          (drh      31-Aug-06):  */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** The code in this file is only compiled if:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **     * The FTS1 module is being built as an extension
1.1          (drh      31-Aug-06): **       (in which case SQLITE_CORE is not defined), or
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **     * The FTS1 module is being built into the core of
1.1          (drh      31-Aug-06): **       SQLite (in which case SQLITE_ENABLE_FTS1 is defined).
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #include <assert.h>
1.1          (drh      31-Aug-06): #if !defined(__APPLE__)
1.1          (drh      31-Aug-06): #include <malloc.h>
1.1          (drh      31-Aug-06): #else
1.1          (drh      31-Aug-06): #include <stdlib.h>
1.1          (drh      31-Aug-06): #endif
1.1          (drh      31-Aug-06): #include <stdio.h>
1.1          (drh      31-Aug-06): #include <string.h>
1.1          (drh      31-Aug-06): #include <ctype.h>
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #include "fts1.h"
1.1          (drh      31-Aug-06): #include "fts1_hash.h"
1.1          (drh      31-Aug-06): #include "fts1_tokenizer.h"
1.1          (drh      31-Aug-06): #include "sqlite3.h"
1.1          (drh      31-Aug-06): #include "sqlite3ext.h"
1.1          (drh      31-Aug-06): SQLITE_EXTENSION_INIT1
1.1          (drh      31-Aug-06): 
1.5          (drh      02-Sep-06): 
1.5          (drh      02-Sep-06): #if 0
1.5          (drh      02-Sep-06): # define TRACE(A)  printf A; fflush(stdout)
1.5          (drh      02-Sep-06): #else
1.5          (drh      02-Sep-06): # define TRACE(A)
1.5          (drh      02-Sep-06): #endif
1.5          (drh      02-Sep-06): 
1.1          (drh      31-Aug-06): /* utility functions */
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): typedef struct StringBuffer {
1.20         (drh      14-Sep-06):   int len;      /* length, not including null terminator */
1.20         (drh      14-Sep-06):   int alloced;  /* Space allocated for s[] */ 
1.20         (drh      14-Sep-06):   char *s;      /* Content of the string */
1.14         (adamd    13-Sep-06): } StringBuffer;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06): void initStringBuffer(StringBuffer *sb){
1.14         (adamd    13-Sep-06):   sb->len = 0;
1.20         (drh      14-Sep-06):   sb->alloced = 100;
1.20         (drh      14-Sep-06):   sb->s = malloc(100);
1.14         (adamd    13-Sep-06):   sb->s[0] = '\0';
1.14         (adamd    13-Sep-06): }
1.14         (adamd    13-Sep-06): 
1.26         (drh      21-Sep-06): void nappend(StringBuffer *sb, const char *zFrom, int nFrom){
1.20         (drh      14-Sep-06):   if( sb->len + nFrom >= sb->alloced ){
1.20         (drh      14-Sep-06):     sb->alloced = sb->len + nFrom + 100;
1.20         (drh      14-Sep-06):     sb->s = realloc(sb->s, sb->alloced+1);
1.20         (drh      14-Sep-06):     if( sb->s==0 ){
1.20         (drh      14-Sep-06):       initStringBuffer(sb);
1.20         (drh      14-Sep-06):       return;
1.20         (drh      14-Sep-06):     }
1.20         (drh      14-Sep-06):   }
1.26         (drh      21-Sep-06):   memcpy(sb->s + sb->len, zFrom, nFrom);
1.14         (adamd    13-Sep-06):   sb->len += nFrom;
1.26         (drh      21-Sep-06):   sb->s[sb->len] = 0;
1.26         (drh      21-Sep-06): }
1.26         (drh      21-Sep-06): void append(StringBuffer *sb, const char *zFrom){
1.26         (drh      21-Sep-06):   nappend(sb, zFrom, strlen(zFrom));
1.14         (adamd    13-Sep-06): }
1.14         (adamd    13-Sep-06): 
1.1          (drh      31-Aug-06): /* We encode variable-length integers in little-endian order using seven bits
1.1          (drh      31-Aug-06):  * per byte as follows:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** KEY:
1.1          (drh      31-Aug-06): **         A = 0xxxxxxx    7 bits of data and one flag bit
1.1          (drh      31-Aug-06): **         B = 1xxxxxxx    7 bits of data and one flag bit
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **  7 bits - A
1.1          (drh      31-Aug-06): ** 14 bits - BA
1.1          (drh      31-Aug-06): ** 21 bits - BBA
1.1          (drh      31-Aug-06): ** and so on.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* We may need up to VARINT_MAX bytes to store an encoded 64-bit integer. */
1.1          (drh      31-Aug-06): #define VARINT_MAX 10
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Write a 64-bit variable-length integer to memory starting at p[0].
1.1          (drh      31-Aug-06):  * The length of data written will be between 1 and VARINT_MAX bytes.
1.1          (drh      31-Aug-06):  * The number of bytes written is returned. */
1.1          (drh      31-Aug-06): static int putVarint(char *p, sqlite_int64 v){
1.1          (drh      31-Aug-06):   unsigned char *q = (unsigned char *) p;
1.1          (drh      31-Aug-06):   sqlite_uint64 vu = v;
1.1          (drh      31-Aug-06):   do{
1.1          (drh      31-Aug-06):     *q++ = (unsigned char) ((vu & 0x7f) | 0x80);
1.1          (drh      31-Aug-06):     vu >>= 7;
1.1          (drh      31-Aug-06):   }while( vu!=0 );
1.1          (drh      31-Aug-06):   q[-1] &= 0x7f;  /* turn off high bit in final byte */
1.1          (drh      31-Aug-06):   assert( q - (unsigned char *)p <= VARINT_MAX );
1.1          (drh      31-Aug-06):   return (int) (q - (unsigned char *)p);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Read a 64-bit variable-length integer from memory starting at p[0].
1.1          (drh      31-Aug-06):  * Return the number of bytes read, or 0 on error.
1.1          (drh      31-Aug-06):  * The value is stored in *v. */
1.1          (drh      31-Aug-06): static int getVarint(const char *p, sqlite_int64 *v){
1.1          (drh      31-Aug-06):   const unsigned char *q = (const unsigned char *) p;
1.1          (drh      31-Aug-06):   sqlite_uint64 x = 0, y = 1;
1.1          (drh      31-Aug-06):   while( (*q & 0x80) == 0x80 ){
1.1          (drh      31-Aug-06):     x += y * (*q++ & 0x7f);
1.1          (drh      31-Aug-06):     y <<= 7;
1.1          (drh      31-Aug-06):     if( q - (unsigned char *)p >= VARINT_MAX ){  /* bad data */
1.1          (drh      31-Aug-06):       assert( 0 );
1.1          (drh      31-Aug-06):       return 0;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   x += y * (*q++);
1.1          (drh      31-Aug-06):   *v = (sqlite_int64) x;
1.1          (drh      31-Aug-06):   return (int) (q - (unsigned char *)p);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int getVarint32(const char *p, int *pi){
1.1          (drh      31-Aug-06):  sqlite_int64 i;
1.1          (drh      31-Aug-06):  int ret = getVarint(p, &i);
1.1          (drh      31-Aug-06):  *pi = (int) i;
1.1          (drh      31-Aug-06):  assert( *pi==i );
1.1          (drh      31-Aug-06):  return ret;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*** Document lists ***
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * A document list holds a sorted list of varint-encoded document IDs.
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * A doclist with type DL_POSITIONS_OFFSETS is stored like this:
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * array {
1.1          (drh      31-Aug-06):  *   varint docid;
1.1          (drh      31-Aug-06):  *   array {
1.14         (adamd    13-Sep-06):  *     varint position;     (delta from previous position plus POS_BASE)
1.1          (drh      31-Aug-06):  *     varint startOffset;  (delta from previous startOffset)
1.1          (drh      31-Aug-06):  *     varint endOffset;    (delta from startOffset)
1.1          (drh      31-Aug-06):  *   }
1.1          (drh      31-Aug-06):  * }
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * Here, array { X } means zero or more occurrences of X, adjacent in memory.
1.1          (drh      31-Aug-06):  *
1.14         (adamd    13-Sep-06):  * A position list may hold positions for text in multiple columns.  A position
1.14         (adamd    13-Sep-06):  * POS_COLUMN is followed by a varint containing the index of the column for
1.14         (adamd    13-Sep-06):  * following positions in the list.  Any positions appearing before any
1.14         (adamd    13-Sep-06):  * occurrences of POS_COLUMN are for column 0.
1.14         (adamd    13-Sep-06):  *
1.1          (drh      31-Aug-06):  * A doclist with type DL_POSITIONS is like the above, but holds only docids
1.1          (drh      31-Aug-06):  * and positions without offset information.
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * A doclist with type DL_DOCIDS is like the above, but holds only docids
1.1          (drh      31-Aug-06):  * without positions or offset information.
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * On disk, every document list has positions and offsets, so we don't bother
1.1          (drh      31-Aug-06):  * to serialize a doclist's type.
1.1          (drh      31-Aug-06):  * 
1.1          (drh      31-Aug-06):  * We don't yet delta-encode document IDs; doing so will probably be a
1.1          (drh      31-Aug-06):  * modest win.
1.1          (drh      31-Aug-06):  *
1.1          (drh      31-Aug-06):  * NOTE(shess) I've thought of a slightly (1%) better offset encoding.
1.1          (drh      31-Aug-06):  * After the first offset, estimate the next offset by using the
1.1          (drh      31-Aug-06):  * current token position and the previous token position and offset,
1.1          (drh      31-Aug-06):  * offset to handle some variance.  So the estimate would be
1.1          (drh      31-Aug-06):  * (iPosition*w->iStartOffset/w->iPosition-64), which is delta-encoded
1.1          (drh      31-Aug-06):  * as normal.  Offsets more than 64 chars from the estimate are
1.1          (drh      31-Aug-06):  * encoded as the delta to the previous start offset + 128.  An
1.1          (drh      31-Aug-06):  * additional tiny increment can be gained by using the end offset of
1.1          (drh      31-Aug-06):  * the previous token to make the estimate a tiny bit more precise.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): typedef enum DocListType {
1.1          (drh      31-Aug-06):   DL_DOCIDS,              /* docids only */
1.1          (drh      31-Aug-06):   DL_POSITIONS,           /* docids + positions */
1.1          (drh      31-Aug-06):   DL_POSITIONS_OFFSETS    /* docids + positions + offsets */
1.1          (drh      31-Aug-06): } DocListType;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): typedef struct DocList {
1.1          (drh      31-Aug-06):   char *pData;
1.1          (drh      31-Aug-06):   int nData;
1.1          (drh      31-Aug-06):   DocListType iType;
1.14         (adamd    13-Sep-06):   int iLastColumn;    /* the last column written */
1.1          (drh      31-Aug-06):   int iLastPos;       /* the last position written */
1.1          (drh      31-Aug-06):   int iLastOffset;    /* the last start offset written */
1.1          (drh      31-Aug-06): } DocList;
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): enum {
1.14         (adamd    13-Sep-06):   POS_END = 0,        /* end of this position list */
1.14         (adamd    13-Sep-06):   POS_COLUMN,         /* followed by new column number */
1.14         (adamd    13-Sep-06):   POS_BASE
1.14         (adamd    13-Sep-06): };
1.14         (adamd    13-Sep-06): 
1.1          (drh      31-Aug-06): /* Initialize a new DocList to hold the given data. */
1.1          (drh      31-Aug-06): static void docListInit(DocList *d, DocListType iType,
1.1          (drh      31-Aug-06):                         const char *pData, int nData){
1.1          (drh      31-Aug-06):   d->nData = nData;
1.1          (drh      31-Aug-06):   if( nData>0 ){
1.1          (drh      31-Aug-06):     d->pData = malloc(nData);
1.1          (drh      31-Aug-06):     memcpy(d->pData, pData, nData);
1.1          (drh      31-Aug-06):   } else {
1.1          (drh      31-Aug-06):     d->pData = NULL;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   d->iType = iType;
1.14         (adamd    13-Sep-06):   d->iLastColumn = 0;
1.14         (adamd    13-Sep-06):   d->iLastPos = d->iLastOffset = 0;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Create a new dynamically-allocated DocList. */
1.1          (drh      31-Aug-06): static DocList *docListNew(DocListType iType){
1.1          (drh      31-Aug-06):   DocList *d = (DocList *) malloc(sizeof(DocList));
1.1          (drh      31-Aug-06):   docListInit(d, iType, 0, 0);
1.1          (drh      31-Aug-06):   return d;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static void docListDestroy(DocList *d){
1.1          (drh      31-Aug-06):   free(d->pData);
1.1          (drh      31-Aug-06): #ifndef NDEBUG
1.1          (drh      31-Aug-06):   memset(d, 0x55, sizeof(*d));
1.1          (drh      31-Aug-06): #endif
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static void docListDelete(DocList *d){
1.1          (drh      31-Aug-06):   docListDestroy(d);
1.1          (drh      31-Aug-06):   free(d);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static char *docListEnd(DocList *d){
1.1          (drh      31-Aug-06):   return d->pData + d->nData;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Append a varint to a DocList's data. */
1.1          (drh      31-Aug-06): static void appendVarint(DocList *d, sqlite_int64 i){
1.1          (drh      31-Aug-06):   char c[VARINT_MAX];
1.1          (drh      31-Aug-06):   int n = putVarint(c, i);
1.1          (drh      31-Aug-06):   d->pData = realloc(d->pData, d->nData + n);
1.1          (drh      31-Aug-06):   memcpy(d->pData + d->nData, c, n);
1.1          (drh      31-Aug-06):   d->nData += n;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static void docListAddDocid(DocList *d, sqlite_int64 iDocid){
1.1          (drh      31-Aug-06):   appendVarint(d, iDocid);
1.3          (adamd    02-Sep-06):   if( d->iType>=DL_POSITIONS ){
1.14         (adamd    13-Sep-06):     appendVarint(d, POS_END);  /* initially empty position list */
1.14         (adamd    13-Sep-06):     d->iLastColumn = 0;
1.14         (adamd    13-Sep-06):     d->iLastPos = d->iLastOffset = 0;
1.3          (adamd    02-Sep-06):   }
1.3          (adamd    02-Sep-06): }
1.3          (adamd    02-Sep-06): 
1.3          (adamd    02-Sep-06): /* helper function for docListAddPos and docListAddPosOffset */
1.14         (adamd    13-Sep-06): static void addPos(DocList *d, int iColumn, int iPos){
1.14         (adamd    13-Sep-06):   assert( d->nData>0 );
1.14         (adamd    13-Sep-06):   --d->nData;  /* remove previous terminator */
1.14         (adamd    13-Sep-06):   if( iColumn!=d->iLastColumn ){
1.14         (adamd    13-Sep-06):     assert( iColumn>d->iLastColumn );
1.14         (adamd    13-Sep-06):     appendVarint(d, POS_COLUMN);
1.14         (adamd    13-Sep-06):     appendVarint(d, iColumn);
1.14         (adamd    13-Sep-06):     d->iLastColumn = iColumn;
1.14         (adamd    13-Sep-06):     d->iLastPos = d->iLastOffset = 0;
1.14         (adamd    13-Sep-06):   }
1.14         (adamd    13-Sep-06):   assert( iPos>=d->iLastPos );
1.14         (adamd    13-Sep-06):   appendVarint(d, iPos-d->iLastPos+POS_BASE);
1.3          (adamd    02-Sep-06):   d->iLastPos = iPos;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Add a position to the last position list in a doclist. */
1.14         (adamd    13-Sep-06): static void docListAddPos(DocList *d, int iColumn, int iPos){
1.3          (adamd    02-Sep-06):   assert( d->iType==DL_POSITIONS );
1.14         (adamd    13-Sep-06):   addPos(d, iColumn, iPos);
1.14         (adamd    13-Sep-06):   appendVarint(d, POS_END);  /* add new terminator */
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): static void docListAddPosOffset(DocList *d, int iColumn, int iPos,
1.1          (drh      31-Aug-06):                                 int iStartOffset, int iEndOffset){
1.1          (drh      31-Aug-06):   assert( d->iType==DL_POSITIONS_OFFSETS );
1.14         (adamd    13-Sep-06):   addPos(d, iColumn, iPos);
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   assert( iStartOffset>=d->iLastOffset );
1.1          (drh      31-Aug-06):   appendVarint(d, iStartOffset-d->iLastOffset);
1.1          (drh      31-Aug-06):   d->iLastOffset = iStartOffset;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   assert( iEndOffset>=iStartOffset );
1.1          (drh      31-Aug-06):   appendVarint(d, iEndOffset-iStartOffset);
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   appendVarint(d, POS_END);  /* add new terminator */
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /*
1.8          (drh      09-Sep-06): ** A DocListReader object is a cursor into a doclist.  Initialize
1.8          (drh      09-Sep-06): ** the cursor to the beginning of the doclist by calling readerInit().
1.8          (drh      09-Sep-06): ** Then use routines
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): **      peekDocid()
1.8          (drh      09-Sep-06): **      readDocid()
1.8          (drh      09-Sep-06): **      readPosition()
1.8          (drh      09-Sep-06): **      skipPositionList()
1.8          (drh      09-Sep-06): **      and so forth...
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** to read information out of the doclist.  When we reach the end
1.8          (drh      09-Sep-06): ** of the doclist, atEnd() returns TRUE.
1.8          (drh      09-Sep-06): */
1.1          (drh      31-Aug-06): typedef struct DocListReader {
1.8          (drh      09-Sep-06):   DocList *pDoclist;  /* The document list we are stepping through */
1.8          (drh      09-Sep-06):   char *p;            /* Pointer to next unread byte in the doclist */
1.14         (adamd    13-Sep-06):   int iLastColumn;
1.3          (adamd    02-Sep-06):   int iLastPos;  /* the last position read, or -1 when not in a position list */
1.1          (drh      31-Aug-06): } DocListReader;
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /*
1.8          (drh      09-Sep-06): ** Initialize the DocListReader r to point to the beginning of pDoclist.
1.8          (drh      09-Sep-06): */
1.1          (drh      31-Aug-06): static void readerInit(DocListReader *r, DocList *pDoclist){
1.1          (drh      31-Aug-06):   r->pDoclist = pDoclist;
1.1          (drh      31-Aug-06):   if( pDoclist!=NULL ){
1.1          (drh      31-Aug-06):     r->p = pDoclist->pData;
1.1          (drh      31-Aug-06):   }
1.14         (adamd    13-Sep-06):   r->iLastColumn = -1;
1.3          (adamd    02-Sep-06):   r->iLastPos = -1;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /*
1.8          (drh      09-Sep-06): ** Return TRUE if we have reached then end of pReader and there is
1.8          (drh      09-Sep-06): ** nothing else left to read.
1.8          (drh      09-Sep-06): */
1.3          (adamd    02-Sep-06): static int atEnd(DocListReader *pReader){
1.8          (drh      09-Sep-06):   return pReader->pDoclist==0 || (pReader->p >= docListEnd(pReader->pDoclist));
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /* Peek at the next docid without advancing the read pointer. 
1.8          (drh      09-Sep-06): */
1.1          (drh      31-Aug-06): static sqlite_int64 peekDocid(DocListReader *pReader){
1.1          (drh      31-Aug-06):   sqlite_int64 ret;
1.3          (adamd    02-Sep-06):   assert( !atEnd(pReader) );
1.3          (adamd    02-Sep-06):   assert( pReader->iLastPos==-1 );
1.1          (drh      31-Aug-06):   getVarint(pReader->p, &ret);
1.1          (drh      31-Aug-06):   return ret;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.9          (drh      10-Sep-06): /* Read the next docid.   See also nextValidDocid().
1.8          (drh      09-Sep-06): */
1.1          (drh      31-Aug-06): static sqlite_int64 readDocid(DocListReader *pReader){
1.1          (drh      31-Aug-06):   sqlite_int64 ret;
1.3          (adamd    02-Sep-06):   assert( !atEnd(pReader) );
1.3          (adamd    02-Sep-06):   assert( pReader->iLastPos==-1 );
1.1          (drh      31-Aug-06):   pReader->p += getVarint(pReader->p, &ret);
1.3          (adamd    02-Sep-06):   if( pReader->pDoclist->iType>=DL_POSITIONS ){
1.14         (adamd    13-Sep-06):     pReader->iLastColumn = 0;
1.3          (adamd    02-Sep-06):     pReader->iLastPos = 0;
1.3          (adamd    02-Sep-06):   }
1.1          (drh      31-Aug-06):   return ret;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): /* Read the next position and column index from a position list.
1.1          (drh      31-Aug-06):  * Returns the position, or -1 at the end of the list. */
1.14         (adamd    13-Sep-06): static int readPosition(DocListReader *pReader, int *iColumn){
1.1          (drh      31-Aug-06):   int i;
1.1          (drh      31-Aug-06):   int iType = pReader->pDoclist->iType;
1.8          (drh      09-Sep-06): 
1.9          (drh      10-Sep-06):   if( pReader->iLastPos==-1 ){
1.9          (drh      10-Sep-06):     return -1;
1.9          (drh      10-Sep-06):   }
1.3          (adamd    02-Sep-06):   assert( !atEnd(pReader) );
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06):   if( iType<DL_POSITIONS ){
1.8          (drh      09-Sep-06):     return -1;
1.8          (drh      09-Sep-06):   }
1.1          (drh      31-Aug-06):   pReader->p += getVarint32(pReader->p, &i);
1.14         (adamd    13-Sep-06):   if( i==POS_END ){
1.14         (adamd    13-Sep-06):     pReader->iLastColumn = pReader->iLastPos = -1;
1.14         (adamd    13-Sep-06):     *iColumn = -1;
1.1          (drh      31-Aug-06):     return -1;
1.1          (drh      31-Aug-06):   }
1.14         (adamd    13-Sep-06):   if( i==POS_COLUMN ){
1.14         (adamd    13-Sep-06):     pReader->p += getVarint32(pReader->p, &pReader->iLastColumn);
1.14         (adamd    13-Sep-06):     pReader->iLastPos = 0;
1.14         (adamd    13-Sep-06):     pReader->p += getVarint32(pReader->p, &i);
1.14         (adamd    13-Sep-06):     assert( i>=POS_BASE );
1.14         (adamd    13-Sep-06):   }
1.14         (adamd    13-Sep-06):   pReader->iLastPos += ((int) i)-POS_BASE;
1.1          (drh      31-Aug-06):   if( iType>=DL_POSITIONS_OFFSETS ){
1.1          (drh      31-Aug-06):     /* Skip over offsets, ignoring them for now. */
1.1          (drh      31-Aug-06):     int iStart, iEnd;
1.1          (drh      31-Aug-06):     pReader->p += getVarint32(pReader->p, &iStart);
1.1          (drh      31-Aug-06):     pReader->p += getVarint32(pReader->p, &iEnd);
1.1          (drh      31-Aug-06):   }
1.14         (adamd    13-Sep-06):   *iColumn = pReader->iLastColumn;
1.1          (drh      31-Aug-06):   return pReader->iLastPos;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Skip past the end of a position list. */
1.1          (drh      31-Aug-06): static void skipPositionList(DocListReader *pReader){
1.8          (drh      09-Sep-06):   DocList *p = pReader->pDoclist;
1.8          (drh      09-Sep-06):   if( p && p->iType>=DL_POSITIONS ){
1.14         (adamd    13-Sep-06):     int iColumn;
1.14         (adamd    13-Sep-06):     while( readPosition(pReader, &iColumn)!=-1 ){}
1.8          (drh      09-Sep-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Skip over a docid, including its position list if the doclist has
1.1          (drh      31-Aug-06):  * positions. */
1.1          (drh      31-Aug-06): static void skipDocument(DocListReader *pReader){
1.1          (drh      31-Aug-06):   readDocid(pReader);
1.8          (drh      09-Sep-06):   skipPositionList(pReader);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.3          (adamd    02-Sep-06): /* Skip past all docids which are less than [iDocid].  Returns 1 if a docid
1.3          (adamd    02-Sep-06):  * matching [iDocid] was found.  */
1.3          (adamd    02-Sep-06): static int skipToDocid(DocListReader *pReader, sqlite_int64 iDocid){
1.3          (adamd    02-Sep-06):   sqlite_int64 d = 0;
1.3          (adamd    02-Sep-06):   while( !atEnd(pReader) && (d=peekDocid(pReader))<iDocid ){
1.3          (adamd    02-Sep-06):     skipDocument(pReader);
1.3          (adamd    02-Sep-06):   }
1.3          (adamd    02-Sep-06):   return !atEnd(pReader) && d==iDocid;
1.3          (adamd    02-Sep-06): }
1.3          (adamd    02-Sep-06): 
1.8          (drh      09-Sep-06): /* Return the first document in a document list.
1.8          (drh      09-Sep-06): */
1.1          (drh      31-Aug-06): static sqlite_int64 firstDocid(DocList *d){
1.1          (drh      31-Aug-06):   DocListReader r;
1.1          (drh      31-Aug-06):   readerInit(&r, d);
1.1          (drh      31-Aug-06):   return readDocid(&r);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): #ifdef SQLITE_DEBUG
1.8          (drh      09-Sep-06): /*
1.8          (drh      09-Sep-06): ** This routine is used for debugging purpose only.
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** Write the content of a doclist to standard output.
1.8          (drh      09-Sep-06): */
1.8          (drh      09-Sep-06): static void printDoclist(DocList *p){
1.8          (drh      09-Sep-06):   DocListReader r;
1.8          (drh      09-Sep-06):   const char *zSep = "";
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06):   readerInit(&r, p);
1.8          (drh      09-Sep-06):   while( !atEnd(&r) ){
1.8          (drh      09-Sep-06):     sqlite_int64 docid = readDocid(&r);
1.8          (drh      09-Sep-06):     if( docid==0 ){
1.8          (drh      09-Sep-06):       skipPositionList(&r);
1.8          (drh      09-Sep-06):       continue;
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06):     printf("%s%lld", zSep, docid);
1.8          (drh      09-Sep-06):     zSep =  ",";
1.8          (drh      09-Sep-06):     if( p->iType>=DL_POSITIONS ){
1.15         (drh      13-Sep-06):       int iPos, iCol;
1.8          (drh      09-Sep-06):       const char *zDiv = "";
1.8          (drh      09-Sep-06):       printf("(");
1.15         (drh      13-Sep-06):       while( (iPos = readPosition(&r, &iCol))>=0 ){
1.15         (drh      13-Sep-06):         printf("%s%d:%d", zDiv, iCol, iPos);
1.8          (drh      09-Sep-06):         zDiv = ":";
1.8          (drh      09-Sep-06):       }
1.8          (drh      09-Sep-06):       printf(")");
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06):   }
1.8          (drh      09-Sep-06):   printf("\n");
1.8          (drh      09-Sep-06):   fflush(stdout);
1.8          (drh      09-Sep-06): }
1.8          (drh      09-Sep-06): #endif /* SQLITE_DEBUG */
1.8          (drh      09-Sep-06): 
1.14         (adamd    13-Sep-06): /* Trim the given doclist to contain only positions in column [iRestrictColumn],
1.14         (adamd    13-Sep-06):  * discarding any docids without any remaining positions. */
1.14         (adamd    13-Sep-06): static void docListRestrictColumn(DocList *in, int iRestrictColumn){
1.14         (adamd    13-Sep-06):   DocListReader r;
1.14         (adamd    13-Sep-06):   DocList out;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   assert( in->iType>=DL_POSITIONS );
1.14         (adamd    13-Sep-06):   readerInit(&r, in);
1.14         (adamd    13-Sep-06):   docListInit(&out, DL_POSITIONS, NULL, 0);
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   while( !atEnd(&r) ){
1.14         (adamd    13-Sep-06):     sqlite_int64 iDocid = readDocid(&r);
1.14         (adamd    13-Sep-06):     int match = 0;
1.14         (adamd    13-Sep-06):     int iPos, iColumn;
1.14         (adamd    13-Sep-06):     while( (iPos = readPosition(&r, &iColumn)) != -1 ){
1.14         (adamd    13-Sep-06):       if( iColumn==iRestrictColumn ){
1.14         (adamd    13-Sep-06):         if( !match ){
1.14         (adamd    13-Sep-06):           docListAddDocid(&out, iDocid);
1.14         (adamd    13-Sep-06):           match = 1;
1.14         (adamd    13-Sep-06):         }
1.14         (adamd    13-Sep-06):         docListAddPos(&out, iColumn, iPos);
1.14         (adamd    13-Sep-06):       }
1.14         (adamd    13-Sep-06):     }
1.14         (adamd    13-Sep-06):   }
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   docListDestroy(in);
1.14         (adamd    13-Sep-06):   *in = out;
1.14         (adamd    13-Sep-06): }
1.14         (adamd    13-Sep-06): 
1.7          (shess    08-Sep-06): /* Helper function for docListUpdate() and docListAccumulate().
1.7          (shess    08-Sep-06): ** Splices a doclist element into the doclist represented by r,
1.7          (shess    08-Sep-06): ** leaving r pointing after the newly spliced element.
1.7          (shess    08-Sep-06): */
1.7          (shess    08-Sep-06): static void docListSpliceElement(DocListReader *r, sqlite_int64 iDocid,
1.7          (shess    08-Sep-06):                                  const char *pSource, int nSource){
1.7          (shess    08-Sep-06):   DocList *d = r->pDoclist;
1.7          (shess    08-Sep-06):   char *pTarget;
1.7          (shess    08-Sep-06):   int nTarget, found;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   found = skipToDocid(r, iDocid);
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   /* Describe slice in d to place pSource/nSource. */
1.7          (shess    08-Sep-06):   pTarget = r->p;
1.3          (adamd    02-Sep-06):   if( found ){
1.7          (shess    08-Sep-06):     skipDocument(r);
1.7          (shess    08-Sep-06):     nTarget = r->p-pTarget;
1.7          (shess    08-Sep-06):   }else{
1.7          (shess    08-Sep-06):     nTarget = 0;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   /* The sense of the following is that there are three possibilities.
1.7          (shess    08-Sep-06):   ** If nTarget==nSource, we should not move any memory nor realloc.
1.7          (shess    08-Sep-06):   ** If nTarget>nSource, trim target and realloc.
1.7          (shess    08-Sep-06):   ** If nTarget<nSource, realloc then expand target.
1.7          (shess    08-Sep-06):   */
1.7          (shess    08-Sep-06):   if( nTarget>nSource ){
1.7          (shess    08-Sep-06):     memmove(pTarget+nSource, pTarget+nTarget, docListEnd(d)-(pTarget+nTarget));
1.7          (shess    08-Sep-06):   }
1.7          (shess    08-Sep-06):   if( nTarget!=nSource ){
1.7          (shess    08-Sep-06):     int iDoclist = pTarget-d->pData;
1.7          (shess    08-Sep-06):     d->pData = realloc(d->pData, d->nData+nSource-nTarget);
1.7          (shess    08-Sep-06):     pTarget = d->pData+iDoclist;
1.7          (shess    08-Sep-06):   }
1.7          (shess    08-Sep-06):   if( nTarget<nSource ){
1.7          (shess    08-Sep-06):     memmove(pTarget+nSource, pTarget+nTarget, docListEnd(d)-(pTarget+nTarget));
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   memcpy(pTarget, pSource, nSource);
1.7          (shess    08-Sep-06):   d->nData += nSource-nTarget;
1.7          (shess    08-Sep-06):   r->p = pTarget+nSource;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06): /* Insert/update pUpdate into the doclist. */
1.7          (shess    08-Sep-06): static void docListUpdate(DocList *d, DocList *pUpdate){
1.1          (drh      31-Aug-06):   DocListReader reader;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   assert( d!=NULL && pUpdate!=NULL );
1.7          (shess    08-Sep-06):   assert( d->iType==pUpdate->iType);
1.7          (shess    08-Sep-06): 
1.1          (drh      31-Aug-06):   readerInit(&reader, d);
1.7          (shess    08-Sep-06):   docListSpliceElement(&reader, firstDocid(pUpdate),
1.7          (shess    08-Sep-06):                        pUpdate->pData, pUpdate->nData);
1.7          (shess    08-Sep-06): }
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06): /* Propagate elements from pUpdate to pAcc, overwriting elements with
1.7          (shess    08-Sep-06): ** matching docids.
1.7          (shess    08-Sep-06): */
1.7          (shess    08-Sep-06): static void docListAccumulate(DocList *pAcc, DocList *pUpdate){
1.7          (shess    08-Sep-06):   DocListReader accReader, updateReader;
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):   /* Handle edge cases where one doclist is empty. */
1.7          (shess    08-Sep-06):   assert( pAcc!=NULL );
1.7          (shess    08-Sep-06):   if( pUpdate==NULL || pUpdate->nData==0 ) return;
1.7          (shess    08-Sep-06):   if( pAcc->nData==0 ){
1.7          (shess    08-Sep-06):     pAcc->pData = malloc(pUpdate->nData);
1.7          (shess    08-Sep-06):     memcpy(pAcc->pData, pUpdate->pData, pUpdate->nData);
1.7          (shess    08-Sep-06):     pAcc->nData = pUpdate->nData;
1.7          (shess    08-Sep-06):     return;
1.7          (shess    08-Sep-06):   }
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):   readerInit(&accReader, pAcc);
1.7          (shess    08-Sep-06):   readerInit(&updateReader, pUpdate);
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):   while( !atEnd(&updateReader) ){
1.7          (shess    08-Sep-06):     char *pSource = updateReader.p;
1.7          (shess    08-Sep-06):     sqlite_int64 iDocid = readDocid(&updateReader);
1.7          (shess    08-Sep-06):     skipPositionList(&updateReader);
1.7          (shess    08-Sep-06):     docListSpliceElement(&accReader, iDocid, pSource, updateReader.p-pSource);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /*
1.9          (drh      10-Sep-06): ** Read the next non-deleted docid off of pIn.  Return
1.9          (drh      10-Sep-06): ** 0 if we reach the end of pDoclist.
1.9          (drh      10-Sep-06): */
1.9          (drh      10-Sep-06): static sqlite_int64 nextValidDocid(DocListReader *pIn){
1.9          (drh      10-Sep-06):   sqlite_int64 docid = 0;
1.9          (drh      10-Sep-06):   skipPositionList(pIn);
1.9          (drh      10-Sep-06):   while( !atEnd(pIn) && (docid = readDocid(pIn))==0 ){
1.9          (drh      10-Sep-06):     skipPositionList(pIn);
1.9          (drh      10-Sep-06):   }
1.9          (drh      10-Sep-06):   return docid;
1.9          (drh      10-Sep-06): }
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06): /*
1.8          (drh      09-Sep-06): ** pLeft and pRight are two DocListReaders that are pointing to
1.8          (drh      09-Sep-06): ** positions lists of the same document: iDocid. 
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** If there are no instances in pLeft or pRight where the position
1.9          (drh      10-Sep-06): ** of pLeft is one less than the position of pRight, then this
1.8          (drh      09-Sep-06): ** routine adds nothing to pOut.
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** If there are one or more instances where positions from pLeft
1.9          (drh      10-Sep-06): ** are exactly one less than positions from pRight, then add a new
1.9          (drh      10-Sep-06): ** document record to pOut.  If pOut wants to hold positions, then
1.9          (drh      10-Sep-06): ** include the positions from pRight that are one more than a
1.9          (drh      10-Sep-06): ** position in pLeft.  In other words:  pRight.iPos==pLeft.iPos+1.
1.8          (drh      09-Sep-06): **
1.9          (drh      10-Sep-06): ** pLeft and pRight are left pointing at the next document record.
1.1          (drh      31-Aug-06): */
1.8          (drh      09-Sep-06): static void mergePosList(
1.8          (drh      09-Sep-06):   DocListReader *pLeft,    /* Left position list */
1.8          (drh      09-Sep-06):   DocListReader *pRight,   /* Right position list */
1.8          (drh      09-Sep-06):   sqlite_int64 iDocid,     /* The docid from pLeft and pRight */
1.8          (drh      09-Sep-06):   DocList *pOut            /* Write the merged document record here */
1.8          (drh      09-Sep-06): ){
1.14         (adamd    13-Sep-06):   int iLeftCol, iLeftPos = readPosition(pLeft, &iLeftCol);
1.14         (adamd    13-Sep-06):   int iRightCol, iRightPos = readPosition(pRight, &iRightCol);
1.1          (drh      31-Aug-06):   int match = 0;
1.3          (adamd    02-Sep-06): 
1.3          (adamd    02-Sep-06):   /* Loop until we've reached the end of both position lists. */
1.8          (drh      09-Sep-06):   while( iLeftPos!=-1 && iRightPos!=-1 ){
1.14         (adamd    13-Sep-06):     if( iLeftCol==iRightCol && iLeftPos+1==iRightPos ){
1.1          (drh      31-Aug-06):       if( !match ){
1.8          (drh      09-Sep-06):         docListAddDocid(pOut, iDocid);
1.1          (drh      31-Aug-06):         match = 1;
1.1          (drh      31-Aug-06):       }
1.8          (drh      09-Sep-06):       if( pOut->iType>=DL_POSITIONS ){
1.14         (adamd    13-Sep-06):         docListAddPos(pOut, iRightCol, iRightPos);
1.8          (drh      09-Sep-06):       }
1.14         (adamd    13-Sep-06):       iLeftPos = readPosition(pLeft, &iLeftCol);
1.14         (adamd    13-Sep-06):       iRightPos = readPosition(pRight, &iRightCol);
1.14         (adamd    13-Sep-06):     }else if( iRightCol<iLeftCol ||
1.15         (drh      13-Sep-06):               (iRightCol==iLeftCol && iRightPos<iLeftPos+1) ){
1.14         (adamd    13-Sep-06):       iRightPos = readPosition(pRight, &iRightCol);
1.8          (drh      09-Sep-06):     }else{
1.14         (adamd    13-Sep-06):       iLeftPos = readPosition(pLeft, &iLeftCol);
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06):   }
1.8          (drh      09-Sep-06):   if( iLeftPos>=0 ) skipPositionList(pLeft);
1.8          (drh      09-Sep-06):   if( iRightPos>=0 ) skipPositionList(pRight);
1.8          (drh      09-Sep-06): }
1.8          (drh      09-Sep-06): 
1.9          (drh      10-Sep-06): /* We have two doclists:  pLeft and pRight.
1.9          (drh      10-Sep-06): ** Write the phrase intersection of these two doclists into pOut.
1.9          (drh      10-Sep-06): **
1.9          (drh      10-Sep-06): ** A phrase intersection means that two documents only match
1.9          (drh      10-Sep-06): ** if pLeft.iPos+1==pRight.iPos.
1.9          (drh      10-Sep-06): **
1.9          (drh      10-Sep-06): ** The output pOut may or may not contain positions.  If pOut
1.9          (drh      10-Sep-06): ** does contain positions, they are the positions of pRight.
1.8          (drh      09-Sep-06): */
1.9          (drh      10-Sep-06): static void docListPhraseMerge(
1.9          (drh      10-Sep-06):   DocList *pLeft,    /* Doclist resulting from the words on the left */
1.9          (drh      10-Sep-06):   DocList *pRight,   /* Doclist for the next word to the right */
1.9          (drh      10-Sep-06):   DocList *pOut      /* Write the combined doclist here */
1.9          (drh      10-Sep-06): ){
1.9          (drh      10-Sep-06):   DocListReader left, right;
1.9          (drh      10-Sep-06):   sqlite_int64 docidLeft, docidRight;
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06):   readerInit(&left, pLeft);
1.9          (drh      10-Sep-06):   readerInit(&right, pRight);
1.9          (drh      10-Sep-06):   docidLeft = nextValidDocid(&left);
1.9          (drh      10-Sep-06):   docidRight = nextValidDocid(&right);
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06):   while( docidLeft>0 && docidRight>0 ){
1.9          (drh      10-Sep-06):     if( docidLeft<docidRight ){
1.9          (drh      10-Sep-06):       docidLeft = nextValidDocid(&left);
1.9          (drh      10-Sep-06):     }else if( docidRight<docidLeft ){
1.9          (drh      10-Sep-06):       docidRight = nextValidDocid(&right);
1.9          (drh      10-Sep-06):     }else{
1.9          (drh      10-Sep-06):       mergePosList(&left, &right, docidLeft, pOut);
1.9          (drh      10-Sep-06):       docidLeft = nextValidDocid(&left);
1.9          (drh      10-Sep-06):       docidRight = nextValidDocid(&right);
1.9          (drh      10-Sep-06):     }
1.8          (drh      09-Sep-06):   }
1.8          (drh      09-Sep-06): }
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06): /* We have two doclists:  pLeft and pRight.
1.8          (drh      09-Sep-06): ** Write the intersection of these two doclists into pOut.
1.9          (drh      10-Sep-06): ** Only docids are matched.  Position information is ignored.
1.8          (drh      09-Sep-06): **
1.9          (drh      10-Sep-06): ** The output pOut never holds positions.
1.8          (drh      09-Sep-06): */
1.9          (drh      10-Sep-06): static void docListAndMerge(
1.8          (drh      09-Sep-06):   DocList *pLeft,    /* Doclist resulting from the words on the left */
1.8          (drh      09-Sep-06):   DocList *pRight,   /* Doclist for the next word to the right */
1.8          (drh      09-Sep-06):   DocList *pOut      /* Write the combined doclist here */
1.8          (drh      09-Sep-06): ){
1.8          (drh      09-Sep-06):   DocListReader left, right;
1.8          (drh      09-Sep-06):   sqlite_int64 docidLeft, docidRight;
1.8          (drh      09-Sep-06): 
1.9          (drh      10-Sep-06):   assert( pOut->iType<DL_POSITIONS );
1.9          (drh      10-Sep-06): 
1.8          (drh      09-Sep-06):   readerInit(&left, pLeft);
1.8          (drh      09-Sep-06):   readerInit(&right, pRight);
1.8          (drh      09-Sep-06):   docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):   docidRight = nextValidDocid(&right);
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06):   while( docidLeft>0 && docidRight>0 ){
1.8          (drh      09-Sep-06):     if( docidLeft<docidRight ){
1.8          (drh      09-Sep-06):       docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):     }else if( docidRight<docidLeft ){
1.8          (drh      09-Sep-06):       docidRight = nextValidDocid(&right);
1.8          (drh      09-Sep-06):     }else{
1.9          (drh      10-Sep-06):       docListAddDocid(pOut, docidLeft);
1.8          (drh      09-Sep-06):       docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):       docidRight = nextValidDocid(&right);
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.3          (adamd    02-Sep-06): }
1.3          (adamd    02-Sep-06): 
1.8          (drh      09-Sep-06): /* We have two doclists:  pLeft and pRight.
1.9          (drh      10-Sep-06): ** Write the union of these two doclists into pOut.
1.9          (drh      10-Sep-06): ** Only docids are matched.  Position information is ignored.
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** The output pOut never holds positions.
1.8          (drh      09-Sep-06): */
1.9          (drh      10-Sep-06): static void docListOrMerge(
1.8          (drh      09-Sep-06):   DocList *pLeft,    /* Doclist resulting from the words on the left */
1.8          (drh      09-Sep-06):   DocList *pRight,   /* Doclist for the next word to the right */
1.8          (drh      09-Sep-06):   DocList *pOut      /* Write the combined doclist here */
1.8          (drh      09-Sep-06): ){
1.8          (drh      09-Sep-06):   DocListReader left, right;
1.8          (drh      09-Sep-06):   sqlite_int64 docidLeft, docidRight, priorLeft;
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06):   readerInit(&left, pLeft);
1.8          (drh      09-Sep-06):   readerInit(&right, pRight);
1.8          (drh      09-Sep-06):   docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):   docidRight = nextValidDocid(&right);
1.8          (drh      09-Sep-06): 
1.9          (drh      10-Sep-06):   while( docidLeft>0 && docidRight>0 ){
1.9          (drh      10-Sep-06):     if( docidLeft<=docidRight ){
1.8          (drh      09-Sep-06):       docListAddDocid(pOut, docidLeft);
1.9          (drh      10-Sep-06):     }else{
1.9          (drh      10-Sep-06):       docListAddDocid(pOut, docidRight);
1.8          (drh      09-Sep-06):     }
1.9          (drh      10-Sep-06):     priorLeft = docidLeft;
1.9          (drh      10-Sep-06):     if( docidLeft<=docidRight ){
1.8          (drh      09-Sep-06):       docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06):     if( docidRight>0 && docidRight<=priorLeft ){
1.8          (drh      09-Sep-06):       docidRight = nextValidDocid(&right);
1.3          (adamd    02-Sep-06):     }
1.1          (drh      31-Aug-06):   }
1.9          (drh      10-Sep-06):   while( docidLeft>0 ){
1.9          (drh      10-Sep-06):     docListAddDocid(pOut, docidLeft);
1.9          (drh      10-Sep-06):     docidLeft = nextValidDocid(&left);
1.9          (drh      10-Sep-06):   }
1.9          (drh      10-Sep-06):   while( docidRight>0 ){
1.9          (drh      10-Sep-06):     docListAddDocid(pOut, docidRight);
1.9          (drh      10-Sep-06):     docidRight = nextValidDocid(&right);
1.9          (drh      10-Sep-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /* We have two doclists:  pLeft and pRight.
1.9          (drh      10-Sep-06): ** Write into pOut all documents that occur in pLeft but not
1.9          (drh      10-Sep-06): ** in pRight.
1.9          (drh      10-Sep-06): **
1.9          (drh      10-Sep-06): ** Only docids are matched.  Position information is ignored.
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** The output pOut never holds positions.
1.8          (drh      09-Sep-06): */
1.9          (drh      10-Sep-06): static void docListExceptMerge(
1.8          (drh      09-Sep-06):   DocList *pLeft,    /* Doclist resulting from the words on the left */
1.8          (drh      09-Sep-06):   DocList *pRight,   /* Doclist for the next word to the right */
1.8          (drh      09-Sep-06):   DocList *pOut      /* Write the combined doclist here */
1.8          (drh      09-Sep-06): ){
1.8          (drh      09-Sep-06):   DocListReader left, right;
1.8          (drh      09-Sep-06):   sqlite_int64 docidLeft, docidRight, priorLeft;
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06):   readerInit(&left, pLeft);
1.8          (drh      09-Sep-06):   readerInit(&right, pRight);
1.8          (drh      09-Sep-06):   docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):   docidRight = nextValidDocid(&right);
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06):   while( docidLeft>0 && docidRight>0 ){
1.9          (drh      10-Sep-06):     priorLeft = docidLeft;
1.9          (drh      10-Sep-06):     if( docidLeft<docidRight ){
1.8          (drh      09-Sep-06):       docListAddDocid(pOut, docidLeft);
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06):     if( docidLeft<=docidRight ){
1.8          (drh      09-Sep-06):       docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06):     if( docidRight>0 && docidRight<=priorLeft ){
1.8          (drh      09-Sep-06):       docidRight = nextValidDocid(&right);
1.1          (drh      31-Aug-06):     }
1.8          (drh      09-Sep-06):   }
1.8          (drh      09-Sep-06):   while( docidLeft>0 ){
1.8          (drh      09-Sep-06):     docListAddDocid(pOut, docidLeft);
1.8          (drh      09-Sep-06):     docidLeft = nextValidDocid(&left);
1.8          (drh      09-Sep-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): static char *string_dup_n(const char *s, int n){
1.14         (adamd    13-Sep-06):   char *str = malloc(n + 1);
1.14         (adamd    13-Sep-06):   memcpy(str, s, n);
1.14         (adamd    13-Sep-06):   str[n] = '\0';
1.14         (adamd    13-Sep-06):   return str;
1.14         (adamd    13-Sep-06): }
1.14         (adamd    13-Sep-06): 
1.2          (shess    01-Sep-06): /* Duplicate a string; the caller must free() the returned string.
1.2          (shess    01-Sep-06):  * (We don't use strdup() since it's not part of the standard C library and
1.2          (shess    01-Sep-06):  * may not be available everywhere.) */
1.2          (shess    01-Sep-06): static char *string_dup(const char *s){
1.14         (adamd    13-Sep-06):   return string_dup_n(s, strlen(s));
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Format a string, replacing each occurrence of the % character with
1.1          (drh      31-Aug-06):  * zName.  This may be more convenient than sqlite_mprintf()
1.1          (drh      31-Aug-06):  * when one string is used repeatedly in a format string.
1.1          (drh      31-Aug-06):  * The caller must free() the returned string. */
1.1          (drh      31-Aug-06): static char *string_format(const char *zFormat, const char *zName){
1.1          (drh      31-Aug-06):   const char *p;
1.1          (drh      31-Aug-06):   size_t len = 0;
1.1          (drh      31-Aug-06):   size_t nName = strlen(zName);
1.1          (drh      31-Aug-06):   char *result;
1.1          (drh      31-Aug-06):   char *r;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* first compute length needed */
1.1          (drh      31-Aug-06):   for(p = zFormat ; *p ; ++p){
1.1          (drh      31-Aug-06):     len += (*p=='%' ? nName : 1);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   len += 1;  /* for null terminator */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   r = result = malloc(len);
1.1          (drh      31-Aug-06):   for(p = zFormat; *p; ++p){
1.1          (drh      31-Aug-06):     if( *p=='%' ){
1.1          (drh      31-Aug-06):       memcpy(r, zName, nName);
1.1          (drh      31-Aug-06):       r += nName;
1.1          (drh      31-Aug-06):     } else {
1.1          (drh      31-Aug-06):       *r++ = *p;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   *r++ = '\0';
1.1          (drh      31-Aug-06):   assert( r == result + len );
1.1          (drh      31-Aug-06):   return result;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int sql_exec(sqlite3 *db, const char *zName, const char *zFormat){
1.1          (drh      31-Aug-06):   char *zCommand = string_format(zFormat, zName);
1.6          (adamd    05-Sep-06):   int rc;
1.5          (drh      02-Sep-06):   TRACE(("FTS1 sql: %s\n", zCommand));
1.6          (adamd    05-Sep-06):   rc = sqlite3_exec(db, zCommand, NULL, 0, NULL);
1.1          (drh      31-Aug-06):   free(zCommand);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int sql_prepare(sqlite3 *db, const char *zName, sqlite3_stmt **ppStmt,
1.1          (drh      31-Aug-06):                 const char *zFormat){
1.1          (drh      31-Aug-06):   char *zCommand = string_format(zFormat, zName);
1.6          (adamd    05-Sep-06):   int rc;
1.5          (drh      02-Sep-06):   TRACE(("FTS1 prepare: %s\n", zCommand));
1.6          (adamd    05-Sep-06):   rc = sqlite3_prepare(db, zCommand, -1, ppStmt, NULL);
1.1          (drh      31-Aug-06):   free(zCommand);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* end utility functions */
1.1          (drh      31-Aug-06): 
1.19         (drh      13-Sep-06): /* Forward reference */
1.19         (drh      13-Sep-06): typedef struct fulltext_vtab fulltext_vtab;
1.19         (drh      13-Sep-06): 
1.19         (drh      13-Sep-06): /* A single term in a query is represented by an instances of
1.19         (drh      13-Sep-06): ** the following structure.
1.19         (drh      13-Sep-06): */
1.19         (drh      13-Sep-06): typedef struct QueryTerm {
1.19         (drh      13-Sep-06):   short int nPhrase; /* How many following terms are part of the same phrase */
1.20         (drh      14-Sep-06):   short int iPhrase; /* This is the i-th term of a phrase. */
1.19         (drh      13-Sep-06):   short int iColumn; /* Column of the index that must match this term */
1.19         (drh      13-Sep-06):   signed char isOr;  /* this term is preceded by "OR" */
1.19         (drh      13-Sep-06):   signed char isNot; /* this term is preceded by "-" */
1.19         (drh      13-Sep-06):   char *pTerm;       /* text of the term.  '\000' terminated.  malloced */
1.19         (drh      13-Sep-06):   int nTerm;         /* Number of bytes in pTerm[] */
1.19         (drh      13-Sep-06): } QueryTerm;
1.19         (drh      13-Sep-06): 
1.19         (drh      13-Sep-06): 
1.19         (drh      13-Sep-06): /* A query string is parsed into a Query structure.
1.19         (drh      13-Sep-06):  *
1.19         (drh      13-Sep-06):  * We could, in theory, allow query strings to be complicated
1.19         (drh      13-Sep-06):  * nested expressions with precedence determined by parentheses.
1.19         (drh      13-Sep-06):  * But none of the major search engines do this.  (Perhaps the
1.19         (drh      13-Sep-06):  * feeling is that an parenthesized expression is two complex of
1.19         (drh      13-Sep-06):  * an idea for the average user to grasp.)  Taking our lead from
1.19         (drh      13-Sep-06):  * the major search engines, we will allow queries to be a list
1.19         (drh      13-Sep-06):  * of terms (with an implied AND operator) or phrases in double-quotes,
1.19         (drh      13-Sep-06):  * with a single optional "-" before each non-phrase term to designate
1.19         (drh      13-Sep-06):  * negation and an optional OR connector.
1.19         (drh      13-Sep-06):  *
1.19         (drh      13-Sep-06):  * OR binds more tightly than the implied AND, which is what the
1.19         (drh      13-Sep-06):  * major search engines seem to do.  So, for example:
1.19         (drh      13-Sep-06):  * 
1.19         (drh      13-Sep-06):  *    [one two OR three]     ==>    one AND (two OR three)
1.19         (drh      13-Sep-06):  *    [one OR two three]     ==>    (one OR two) AND three
1.19         (drh      13-Sep-06):  *
1.19         (drh      13-Sep-06):  * A "-" before a term matches all entries that lack that term.
1.19         (drh      13-Sep-06):  * The "-" must occur immediately before the term with in intervening
1.19         (drh      13-Sep-06):  * space.  This is how the search engines do it.
1.19         (drh      13-Sep-06):  *
1.19         (drh      13-Sep-06):  * A NOT term cannot be the right-hand operand of an OR.  If this
1.19         (drh      13-Sep-06):  * occurs in the query string, the NOT is ignored:
1.19         (drh      13-Sep-06):  *
1.19         (drh      13-Sep-06):  *    [one OR -two]          ==>    one OR two
1.19         (drh      13-Sep-06):  *
1.19         (drh      13-Sep-06):  */
1.19         (drh      13-Sep-06): typedef struct Query {
1.19         (drh      13-Sep-06):   fulltext_vtab *pFts;  /* The full text index */
1.19         (drh      13-Sep-06):   int nTerms;           /* Number of terms in the query */
1.19         (drh      13-Sep-06):   QueryTerm *pTerms;    /* Array of terms.  Space obtained from malloc() */
1.19         (drh      13-Sep-06):   int nextIsOr;         /* Set the isOr flag on the next inserted term */
1.19         (drh      13-Sep-06):   int nextColumn;       /* Next word parsed must be in this column */
1.19         (drh      13-Sep-06):   int dfltColumn;       /* The default column */
1.19         (drh      13-Sep-06): } Query;
1.19         (drh      13-Sep-06): 
1.19         (drh      13-Sep-06): 
1.20         (drh      14-Sep-06): /*
1.20         (drh      14-Sep-06): ** An instance of the following structure keeps track of generated
1.20         (drh      14-Sep-06): ** matching-word offset information and snippets.
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): typedef struct Snippet {
1.20         (drh      14-Sep-06):   int nMatch;     /* Total number of matches */
1.20         (drh      14-Sep-06):   int nAlloc;     /* Space allocated for aMatch[] */
1.22         (drh      16-Sep-06):   struct snippetMatch { /* One entry for each matching term */
1.26         (drh      21-Sep-06):     char snStatus;       /* Status flag for use while constructing snippets */
1.22         (drh      16-Sep-06):     short int iCol;      /* The column that contains the match */
1.22         (drh      16-Sep-06):     short int iTerm;     /* The index in Query.pTerms[] of the matching term */
1.22         (drh      16-Sep-06):     short int nByte;     /* Number of bytes in the term */
1.22         (drh      16-Sep-06):     int iStart;          /* The offset to the first character of the term */
1.20         (drh      14-Sep-06):   } *aMatch;      /* Points to space obtained from malloc */
1.20         (drh      14-Sep-06):   char *zOffset;  /* Text rendering of aMatch[] */
1.20         (drh      14-Sep-06):   int nOffset;    /* strlen(zOffset) */
1.26         (drh      21-Sep-06):   char *zSnippet; /* Snippet text */
1.26         (drh      21-Sep-06):   int nSnippet;   /* strlen(zSnippet) */
1.20         (drh      14-Sep-06): } Snippet;
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06): 
1.13         (adamd    12-Sep-06): typedef enum QueryType {
1.14         (adamd    13-Sep-06):   QUERY_GENERIC,   /* table scan */
1.14         (adamd    13-Sep-06):   QUERY_ROWID,     /* lookup by rowid */
1.14         (adamd    13-Sep-06):   QUERY_FULLTEXT   /* QUERY_FULLTEXT + [i] is a full-text search for column i*/
1.13         (adamd    12-Sep-06): } QueryType;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06): /* TODO(shess) CHUNK_MAX controls how much data we allow in segment 0
1.7          (shess    08-Sep-06): ** before we start aggregating into larger segments.  Lower CHUNK_MAX
1.7          (shess    08-Sep-06): ** means that for a given input we have more individual segments per
1.7          (shess    08-Sep-06): ** term, which means more rows in the table and a bigger index (due to
1.7          (shess    08-Sep-06): ** both more rows and bigger rowids).  But it also reduces the average
1.7          (shess    08-Sep-06): ** cost of adding new elements to the segment 0 doclist, and it seems
1.7          (shess    08-Sep-06): ** to reduce the number of pages read and written during inserts.  256
1.7          (shess    08-Sep-06): ** was chosen by measuring insertion times for a certain input (first
1.7          (shess    08-Sep-06): ** 10k documents of Enron corpus), though including query performance
1.7          (shess    08-Sep-06): ** in the decision may argue for a larger value.
1.7          (shess    08-Sep-06): */
1.7          (shess    08-Sep-06): #define CHUNK_MAX 256
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): typedef enum fulltext_statement {
1.1          (drh      31-Aug-06):   CONTENT_INSERT_STMT,
1.1          (drh      31-Aug-06):   CONTENT_SELECT_STMT,
1.1          (drh      31-Aug-06):   CONTENT_DELETE_STMT,
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   TERM_SELECT_STMT,
1.7          (shess    08-Sep-06):   TERM_SELECT_ALL_STMT,
1.1          (drh      31-Aug-06):   TERM_INSERT_STMT,
1.1          (drh      31-Aug-06):   TERM_UPDATE_STMT,
1.1          (drh      31-Aug-06):   TERM_DELETE_STMT,
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   MAX_STMT                     /* Always at end! */
1.1          (drh      31-Aug-06): } fulltext_statement;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* These must exactly match the enum above. */
1.1          (drh      31-Aug-06): /* TODO(adam): Is there some risk that a statement (in particular,
1.1          (drh      31-Aug-06): ** pTermSelectStmt) will be used in two cursors at once, e.g.  if a
1.1          (drh      31-Aug-06): ** query joins a virtual table to itself?  If so perhaps we should
1.1          (drh      31-Aug-06): ** move some of these to the cursor object.
1.1          (drh      31-Aug-06): */
1.4          (drh      02-Sep-06): static const char *const fulltext_zStatement[MAX_STMT] = {
1.14         (adamd    13-Sep-06):   /* CONTENT_INSERT */ NULL,  /* generated in contentInsertStatement() */
1.14         (adamd    13-Sep-06):   /* CONTENT_SELECT */ "select * from %_content where rowid = ?",
1.1          (drh      31-Aug-06):   /* CONTENT_DELETE */ "delete from %_content where rowid = ?",
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* TERM_SELECT */
1.7          (shess    08-Sep-06):   "select rowid, doclist from %_term where term = ? and segment = ?",
1.7          (shess    08-Sep-06):   /* TERM_SELECT_ALL */
1.7          (shess    08-Sep-06):   "select doclist from %_term where term = ? order by segment",
1.1          (drh      31-Aug-06):   /* TERM_INSERT */
1.12         (shess    11-Sep-06):   "insert into %_term (rowid, term, segment, doclist) values (?, ?, ?, ?)",
1.1          (drh      31-Aug-06):   /* TERM_UPDATE */ "update %_term set doclist = ? where rowid = ?",
1.1          (drh      31-Aug-06):   /* TERM_DELETE */ "delete from %_term where rowid = ?",
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.19         (drh      13-Sep-06): /*
1.19         (drh      13-Sep-06): ** A connection to a fulltext index is an instance of the following
1.19         (drh      13-Sep-06): ** structure.  The xCreate and xConnect methods create an instance
1.19         (drh      13-Sep-06): ** of this structure and xDestroy and xDisconnect free that instance.
1.19         (drh      13-Sep-06): ** All other methods receive a pointer to the structure as one of their
1.19         (drh      13-Sep-06): ** arguments.
1.19         (drh      13-Sep-06): */
1.19         (drh      13-Sep-06): struct fulltext_vtab {
1.19         (drh      13-Sep-06):   sqlite3_vtab base;               /* Base class used by SQLite core */
1.19         (drh      13-Sep-06):   sqlite3 *db;                     /* The database connection */
1.1          (drh      31-Aug-06):   const char *zName;               /* virtual table name */
1.16         (drh      13-Sep-06):   int nColumn;                     /* number of columns in virtual table */
1.16         (drh      13-Sep-06):   char **azColumn;                 /* column names.  malloced */
1.16         (drh      13-Sep-06):   char *zColumnList;               /* comma-separate list of column names */
1.1          (drh      31-Aug-06):   sqlite3_tokenizer *pTokenizer;   /* tokenizer for inserts and queries */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* Precompiled statements which we keep as long as the table is
1.1          (drh      31-Aug-06):   ** open.
1.1          (drh      31-Aug-06):   */
1.1          (drh      31-Aug-06):   sqlite3_stmt *pFulltextStatements[MAX_STMT];
1.19         (drh      13-Sep-06): };
1.1          (drh      31-Aug-06): 
1.19         (drh      13-Sep-06): /*
1.19         (drh      13-Sep-06): ** When the core wants to do a query, it create a cursor using a
1.19         (drh      13-Sep-06): ** call to xOpen.  This structure is an instance of a cursor.  It
1.19         (drh      13-Sep-06): ** is destroyed by xClose.
1.19         (drh      13-Sep-06): */
1.1          (drh      31-Aug-06): typedef struct fulltext_cursor {
1.19         (drh      13-Sep-06):   sqlite3_vtab_cursor base;        /* Base class used by SQLite core */
1.20         (drh      14-Sep-06):   QueryType iCursorType;           /* Copy of sqlite3_index_info.idxNum */
1.19         (drh      13-Sep-06):   sqlite3_stmt *pStmt;             /* Prepared statement in use by the cursor */
1.19         (drh      13-Sep-06):   int eof;                         /* True if at End Of Results */
1.19         (drh      13-Sep-06):   Query q;                         /* Parsed query string */
1.20         (drh      14-Sep-06):   Snippet snippet;                 /* Cached snippet for the current row */
1.20         (drh      14-Sep-06):   int iColumn;                     /* Column being searched */
1.13         (adamd    12-Sep-06):   DocListReader result;  /* used when iCursorType == QUERY_FULLTEXT */ 
1.1          (drh      31-Aug-06): } fulltext_cursor;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static struct fulltext_vtab *cursor_vtab(fulltext_cursor *c){
1.1          (drh      31-Aug-06):   return (fulltext_vtab *) c->base.pVtab;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.4          (drh      02-Sep-06): static const sqlite3_module fulltextModule;   /* forward declaration */
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): /* Return a dynamically generated statement of the form
1.14         (adamd    13-Sep-06):  *   insert into %_content (rowid, ...) values (?, ...)
1.14         (adamd    13-Sep-06):  */
1.14         (adamd    13-Sep-06): static const char *contentInsertStatement(fulltext_vtab *v){
1.14         (adamd    13-Sep-06):   StringBuffer sb;
1.14         (adamd    13-Sep-06):   int i;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   initStringBuffer(&sb);
1.14         (adamd    13-Sep-06):   append(&sb, "insert into %_content (rowid, ");
1.16         (drh      13-Sep-06):   append(&sb, v->zColumnList);
1.14         (adamd    13-Sep-06):   append(&sb, ") values (?");
1.16         (drh      13-Sep-06):   for(i=0; i<v->nColumn; ++i)
1.14         (adamd    13-Sep-06):     append(&sb, ", ?");
1.14         (adamd    13-Sep-06):   append(&sb, ")");
1.14         (adamd    13-Sep-06):   return sb.s;
1.14         (adamd    13-Sep-06): }
1.14         (adamd    13-Sep-06): 
1.1          (drh      31-Aug-06): /* Puts a freshly-prepared statement determined by iStmt in *ppStmt.
1.1          (drh      31-Aug-06): ** If the indicated statement has never been prepared, it is prepared
1.1          (drh      31-Aug-06): ** and cached, otherwise the cached version is reset.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int sql_get_statement(fulltext_vtab *v, fulltext_statement iStmt,
1.1          (drh      31-Aug-06):                              sqlite3_stmt **ppStmt){
1.1          (drh      31-Aug-06):   assert( iStmt<MAX_STMT );
1.1          (drh      31-Aug-06):   if( v->pFulltextStatements[iStmt]==NULL ){
1.16         (drh      13-Sep-06):     const char *zStmt;
1.16         (drh      13-Sep-06):     int rc;
1.16         (drh      13-Sep-06):     zStmt = iStmt==CONTENT_INSERT_STMT ? contentInsertStatement(v) : 
1.16         (drh      13-Sep-06):                                          fulltext_zStatement[iStmt];
1.16         (drh      13-Sep-06):     rc = sql_prepare(v->db, v->zName, &v->pFulltextStatements[iStmt],
1.14         (adamd    13-Sep-06):                          zStmt);
1.14         (adamd    13-Sep-06):     if( iStmt==CONTENT_INSERT_STMT ) free((void *) zStmt);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06):   } else {
1.1          (drh      31-Aug-06):     int rc = sqlite3_reset(v->pFulltextStatements[iStmt]);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   *ppStmt = v->pFulltextStatements[iStmt];
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Step the indicated statement, handling errors SQLITE_BUSY (by
1.1          (drh      31-Aug-06): ** retrying) and SQLITE_SCHEMA (by re-preparing and transferring
1.1          (drh      31-Aug-06): ** bindings to the new statement).
1.1          (drh      31-Aug-06): ** TODO(adam): We should extend this function so that it can work with
1.1          (drh      31-Aug-06): ** statements declared locally, not only globally cached statements.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int sql_step_statement(fulltext_vtab *v, fulltext_statement iStmt,
1.1          (drh      31-Aug-06):                               sqlite3_stmt **ppStmt){
1.1          (drh      31-Aug-06):   int rc;
1.1          (drh      31-Aug-06):   sqlite3_stmt *s = *ppStmt;
1.1          (drh      31-Aug-06):   assert( iStmt<MAX_STMT );
1.1          (drh      31-Aug-06):   assert( s==v->pFulltextStatements[iStmt] );
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   while( (rc=sqlite3_step(s))!=SQLITE_DONE && rc!=SQLITE_ROW ){
1.1          (drh      31-Aug-06):     sqlite3_stmt *pNewStmt;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     if( rc==SQLITE_BUSY ) continue;
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_ERROR ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     rc = sqlite3_reset(s);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_SCHEMA ) return SQLITE_ERROR;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     v->pFulltextStatements[iStmt] = NULL;   /* Still in s */
1.1          (drh      31-Aug-06):     rc = sql_get_statement(v, iStmt, &pNewStmt);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) goto err;
1.1          (drh      31-Aug-06):     *ppStmt = pNewStmt;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     rc = sqlite3_transfer_bindings(s, pNewStmt);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) goto err;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     rc = sqlite3_finalize(s);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06):     s = pNewStmt;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):  err:
1.1          (drh      31-Aug-06):   sqlite3_finalize(s);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Like sql_step_statement(), but convert SQLITE_DONE to SQLITE_OK.
1.1          (drh      31-Aug-06): ** Useful for statements like UPDATE, where we expect no results.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int sql_single_step_statement(fulltext_vtab *v,
1.1          (drh      31-Aug-06):                                      fulltext_statement iStmt,
1.1          (drh      31-Aug-06):                                      sqlite3_stmt **ppStmt){
1.1          (drh      31-Aug-06):   int rc = sql_step_statement(v, iStmt, ppStmt);
1.1          (drh      31-Aug-06):   return (rc==SQLITE_DONE) ? SQLITE_OK : rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): /* insert into %_content (rowid, ...) values ([rowid], [pValues]) */
1.1          (drh      31-Aug-06): static int content_insert(fulltext_vtab *v, sqlite3_value *rowid,
1.14         (adamd    13-Sep-06):                           sqlite3_value **pValues){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.14         (adamd    13-Sep-06):   int i;
1.1          (drh      31-Aug-06):   int rc = sql_get_statement(v, CONTENT_INSERT_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sqlite3_bind_value(s, 1, rowid);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.16         (drh      13-Sep-06):   for(i=0; i<v->nColumn; ++i){
1.14         (adamd    13-Sep-06):     rc = sqlite3_bind_value(s, 2+i, pValues[i]);
1.14         (adamd    13-Sep-06):     if( rc!=SQLITE_OK ) return rc;
1.14         (adamd    13-Sep-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return sql_single_step_statement(v, CONTENT_INSERT_STMT, &s);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): void freeStringArray(int nString, const char **pString){
1.14         (adamd    13-Sep-06):   int i;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   for (i=0 ; i < nString ; ++i) {
1.14         (adamd    13-Sep-06):     free((void *) pString[i]);
1.14         (adamd    13-Sep-06):   }
1.14         (adamd    13-Sep-06):   free((void *) pString);
1.14         (adamd    13-Sep-06): }
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06): /* select * from %_content where rowid = [iRow]
1.14         (adamd    13-Sep-06):  * The caller must delete the returned array and all strings in it.
1.14         (adamd    13-Sep-06):  *
1.14         (adamd    13-Sep-06):  * TODO: Perhaps we should return pointer/length strings here for consistency
1.14         (adamd    13-Sep-06):  * with other code which uses pointer/length. */
1.1          (drh      31-Aug-06): static int content_select(fulltext_vtab *v, sqlite_int64 iRow,
1.14         (adamd    13-Sep-06):                           const char ***pValues){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.14         (adamd    13-Sep-06):   const char **values;
1.14         (adamd    13-Sep-06):   int i;
1.14         (adamd    13-Sep-06):   int rc;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   *pValues = NULL;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   rc = sql_get_statement(v, CONTENT_SELECT_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sqlite3_bind_int64(s, 1, iRow);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sql_step_statement(v, CONTENT_SELECT_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_ROW ) return rc;
1.1          (drh      31-Aug-06): 
1.16         (drh      13-Sep-06):   values = (const char **) malloc(v->nColumn * sizeof(const char *));
1.16         (drh      13-Sep-06):   for(i=0; i<v->nColumn; ++i){
1.16         (drh      13-Sep-06):     values[i] = string_dup((char*)sqlite3_column_text(s, i));
1.14         (adamd    13-Sep-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* We expect only one row.  We must execute another sqlite3_step()
1.1          (drh      31-Aug-06):    * to complete the iteration; otherwise the table will remain locked. */
1.1          (drh      31-Aug-06):   rc = sqlite3_step(s);
1.14         (adamd    13-Sep-06):   if( rc==SQLITE_DONE ){
1.14         (adamd    13-Sep-06):     *pValues = values;
1.14         (adamd    13-Sep-06):     return SQLITE_OK;
1.14         (adamd    13-Sep-06):   }
1.1          (drh      31-Aug-06): 
1.16         (drh      13-Sep-06):   freeStringArray(v->nColumn, values);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* delete from %_content where rowid = [iRow ] */
1.1          (drh      31-Aug-06): static int content_delete(fulltext_vtab *v, sqlite_int64 iRow){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.1          (drh      31-Aug-06):   int rc = sql_get_statement(v, CONTENT_DELETE_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sqlite3_bind_int64(s, 1, iRow);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return sql_single_step_statement(v, CONTENT_DELETE_STMT, &s);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06): /* select rowid, doclist from %_term
1.7          (shess    08-Sep-06):  *  where term = [pTerm] and segment = [iSegment]
1.7          (shess    08-Sep-06):  * If found, returns SQLITE_ROW; the caller must free the
1.7          (shess    08-Sep-06):  * returned doclist.  If no rows found, returns SQLITE_DONE. */
1.2          (shess    01-Sep-06): static int term_select(fulltext_vtab *v, const char *pTerm, int nTerm,
1.7          (shess    08-Sep-06):                        int iSegment,
1.7          (shess    08-Sep-06):                        sqlite_int64 *rowid, DocList *out){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.1          (drh      31-Aug-06):   int rc = sql_get_statement(v, TERM_SELECT_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06):   rc = sqlite3_bind_text(s, 1, pTerm, nTerm, SQLITE_STATIC);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   rc = sqlite3_bind_int(s, 2, iSegment);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sql_step_statement(v, TERM_SELECT_STMT, &s);
1.7          (shess    08-Sep-06):   if( rc!=SQLITE_ROW ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   *rowid = sqlite3_column_int64(s, 0);
1.1          (drh      31-Aug-06):   docListInit(out, DL_POSITIONS_OFFSETS,
1.1          (drh      31-Aug-06):               sqlite3_column_blob(s, 1), sqlite3_column_bytes(s, 1));
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* We expect only one row.  We must execute another sqlite3_step()
1.1          (drh      31-Aug-06):    * to complete the iteration; otherwise the table will remain locked. */
1.1          (drh      31-Aug-06):   rc = sqlite3_step(s);
1.7          (shess    08-Sep-06):   return rc==SQLITE_DONE ? SQLITE_ROW : rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06): /* Load the segment doclists for term pTerm and merge them in
1.7          (shess    08-Sep-06): ** appropriate order into out.  Returns SQLITE_OK if successful.  If
1.7          (shess    08-Sep-06): ** there are no segments for pTerm, successfully returns an empty
1.7          (shess    08-Sep-06): ** doclist in out.
1.15         (drh      13-Sep-06): **
1.15         (drh      13-Sep-06): ** Each document consists of 1 or more "columns".  The number of
1.15         (drh      13-Sep-06): ** columns is v->nColumn.  If iColumn==v->nColumn, then return
1.15         (drh      13-Sep-06): ** position information about all columns.  If iColumn<v->nColumn,
1.15         (drh      13-Sep-06): ** then only return position information about the iColumn-th column
1.15         (drh      13-Sep-06): ** (where the first column is 0).
1.15         (drh      13-Sep-06): */
1.15         (drh      13-Sep-06): static int term_select_all(
1.15         (drh      13-Sep-06):   fulltext_vtab *v,     /* The fulltext index we are querying against */
1.15         (drh      13-Sep-06):   int iColumn,          /* If <nColumn, only look at the iColumn-th column */
1.15         (drh      13-Sep-06):   const char *pTerm,    /* The term whose posting lists we want */
1.15         (drh      13-Sep-06):   int nTerm,            /* Number of bytes in pTerm */
1.15         (drh      13-Sep-06):   DocList *out          /* Write the resulting doclist here */
1.15         (drh      13-Sep-06): ){
1.7          (shess    08-Sep-06):   DocList doclist;
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.7          (shess    08-Sep-06):   int rc = sql_get_statement(v, TERM_SELECT_ALL_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06):   rc = sqlite3_bind_text(s, 1, pTerm, nTerm, SQLITE_STATIC);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   docListInit(&doclist, DL_POSITIONS_OFFSETS, 0, 0);
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   /* TODO(shess) Handle schema and busy errors. */
1.7          (shess    08-Sep-06):   while( (rc=sql_step_statement(v, TERM_SELECT_ALL_STMT, &s))==SQLITE_ROW ){
1.7          (shess    08-Sep-06):     DocList old;
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):     /* TODO(shess) If we processed doclists from oldest to newest, we
1.7          (shess    08-Sep-06):     ** could skip the malloc() involved with the following call.  For
1.7          (shess    08-Sep-06):     ** now, I'd rather keep this logic similar to index_insert_term().
1.7          (shess    08-Sep-06):     ** We could additionally drop elements when we see deletes, but
1.7          (shess    08-Sep-06):     ** that would require a distinct version of docListAccumulate().
1.7          (shess    08-Sep-06):     */
1.7          (shess    08-Sep-06):     docListInit(&old, doclist.iType,
1.7          (shess    08-Sep-06):                 sqlite3_column_blob(s, 0), sqlite3_column_bytes(s, 0));
1.7          (shess    08-Sep-06): 
1.16         (drh      13-Sep-06):     if( iColumn<v->nColumn ){   /* querying a single column */
1.14         (adamd    13-Sep-06):       docListRestrictColumn(&old, iColumn);
1.14         (adamd    13-Sep-06):     }
1.14         (adamd    13-Sep-06): 
1.7          (shess    08-Sep-06):     /* doclist contains the newer data, so write it over old.  Then
1.7          (shess    08-Sep-06):     ** steal accumulated result for doclist.
1.7          (shess    08-Sep-06):     */
1.7          (shess    08-Sep-06):     docListAccumulate(&old, &doclist);
1.7          (shess    08-Sep-06):     docListDestroy(&doclist);
1.7          (shess    08-Sep-06):     doclist = old;
1.7          (shess    08-Sep-06):   }
1.7          (shess    08-Sep-06):   if( rc!=SQLITE_DONE ){
1.7          (shess    08-Sep-06):     docListDestroy(&doclist);
1.7          (shess    08-Sep-06):     return rc;
1.7          (shess    08-Sep-06):   }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   *out = doclist;
1.7          (shess    08-Sep-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.12         (shess    11-Sep-06): /* insert into %_term (rowid, term, segment, doclist)
1.12         (shess    11-Sep-06):                values ([piRowid], [pTerm], [iSegment], [doclist])
1.12         (shess    11-Sep-06): ** Lets sqlite select rowid if piRowid is NULL, else uses *piRowid.
1.12         (shess    11-Sep-06): **
1.12         (shess    11-Sep-06): ** NOTE(shess) piRowid is IN, with values of "space of int64" plus
1.12         (shess    11-Sep-06): ** null, it is not used to pass data back to the caller.
1.12         (shess    11-Sep-06): */
1.12         (shess    11-Sep-06): static int term_insert(fulltext_vtab *v, sqlite_int64 *piRowid,
1.12         (shess    11-Sep-06):                        const char *pTerm, int nTerm,
1.7          (shess    08-Sep-06):                        int iSegment, DocList *doclist){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.1          (drh      31-Aug-06):   int rc = sql_get_statement(v, TERM_INSERT_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.12         (shess    11-Sep-06):   if( piRowid==NULL ){
1.12         (shess    11-Sep-06):     rc = sqlite3_bind_null(s, 1);
1.12         (shess    11-Sep-06):   }else{
1.12         (shess    11-Sep-06):     rc = sqlite3_bind_int64(s, 1, *piRowid);
1.12         (shess    11-Sep-06):   }
1.12         (shess    11-Sep-06):   if( rc!=SQLITE_OK ) return rc;
1.12         (shess    11-Sep-06): 
1.12         (shess    11-Sep-06):   rc = sqlite3_bind_text(s, 2, pTerm, nTerm, SQLITE_STATIC);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.12         (shess    11-Sep-06):   rc = sqlite3_bind_int(s, 3, iSegment);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.12         (shess    11-Sep-06):   rc = sqlite3_bind_blob(s, 4, doclist->pData, doclist->nData, SQLITE_STATIC);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return sql_single_step_statement(v, TERM_INSERT_STMT, &s);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* update %_term set doclist = [doclist] where rowid = [rowid] */
1.1          (drh      31-Aug-06): static int term_update(fulltext_vtab *v, sqlite_int64 rowid,
1.1          (drh      31-Aug-06):                        DocList *doclist){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.1          (drh      31-Aug-06):   int rc = sql_get_statement(v, TERM_UPDATE_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06):   rc = sqlite3_bind_blob(s, 1, doclist->pData, doclist->nData, SQLITE_STATIC);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sqlite3_bind_int64(s, 2, rowid);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return sql_single_step_statement(v, TERM_UPDATE_STMT, &s);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int term_delete(fulltext_vtab *v, sqlite_int64 rowid){
1.1          (drh      31-Aug-06):   sqlite3_stmt *s;
1.1          (drh      31-Aug-06):   int rc = sql_get_statement(v, TERM_DELETE_STMT, &s);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   rc = sqlite3_bind_int64(s, 1, rowid);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return sql_single_step_statement(v, TERM_DELETE_STMT, &s);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.11         (drh      11-Sep-06): /*
1.11         (drh      11-Sep-06): ** Free the memory used to contain a fulltext_vtab structure.
1.11         (drh      11-Sep-06): */
1.1          (drh      31-Aug-06): static void fulltext_vtab_destroy(fulltext_vtab *v){
1.1          (drh      31-Aug-06):   int iStmt;
1.1          (drh      31-Aug-06): 
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Destroy %p\n", v));
1.1          (drh      31-Aug-06):   for( iStmt=0; iStmt<MAX_STMT; iStmt++ ){
1.1          (drh      31-Aug-06):     if( v->pFulltextStatements[iStmt]!=NULL ){
1.1          (drh      31-Aug-06):       sqlite3_finalize(v->pFulltextStatements[iStmt]);
1.1          (drh      31-Aug-06):       v->pFulltextStatements[iStmt] = NULL;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   if( v->pTokenizer!=NULL ){
1.1          (drh      31-Aug-06):     v->pTokenizer->pModule->xDestroy(v->pTokenizer);
1.1          (drh      31-Aug-06):     v->pTokenizer = NULL;
1.1          (drh      31-Aug-06):   }
1.11         (drh      11-Sep-06):   
1.16         (drh      13-Sep-06):   free(v->azColumn);
1.16         (drh      13-Sep-06):   free(v->zColumnList);
1.1          (drh      31-Aug-06):   free(v);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Token types for parsing the arguments to xConnect or xCreate.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): #define TOKEN_EOF         0    /* End of file */
1.16         (drh      13-Sep-06): #define TOKEN_SPACE       1    /* Any kind of whitespace */
1.16         (drh      13-Sep-06): #define TOKEN_ID          2    /* An identifier */
1.16         (drh      13-Sep-06): #define TOKEN_STRING      3    /* A string literal */
1.16         (drh      13-Sep-06): #define TOKEN_PUNCT       4    /* A single punctuation character */
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** If X is a character that can be used in an identifier then
1.16         (drh      13-Sep-06): ** IdChar(X) will be true.  Otherwise it is false.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** For ASCII, any character with the high-order bit set is
1.16         (drh      13-Sep-06): ** allowed in an identifier.  For 7-bit characters, 
1.16         (drh      13-Sep-06): ** sqlite3IsIdChar[X] must be 1.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** Ticket #1066.  the SQL standard does not allow '$' in the
1.16         (drh      13-Sep-06): ** middle of identfiers.  But many SQL implementations do. 
1.16         (drh      13-Sep-06): ** SQLite will allow '$' in identifiers for compatibility.
1.16         (drh      13-Sep-06): ** But the feature is undocumented.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static const char isIdChar[] = {
1.16         (drh      13-Sep-06): /* x0 x1 x2 x3 x4 x5 x6 x7 x8 x9 xA xB xC xD xE xF */
1.16         (drh      13-Sep-06):     0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0,  /* 2x */
1.16         (drh      13-Sep-06):     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0, 0,  /* 3x */
1.16         (drh      13-Sep-06):     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 4x */
1.16         (drh      13-Sep-06):     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 1,  /* 5x */
1.16         (drh      13-Sep-06):     0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1,  /* 6x */
1.16         (drh      13-Sep-06):     1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 0, 0, 0,  /* 7x */
1.16         (drh      13-Sep-06): };
1.16         (drh      13-Sep-06): #define IdChar(C)  (((c=C)&0x80)!=0 || (c>0x1f && isIdChar[c-0x20]))
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Return the length of the token that begins at z[0]. 
1.16         (drh      13-Sep-06): ** Store the token type in *tokenType before returning.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static int getToken(const char *z, int *tokenType){
1.16         (drh      13-Sep-06):   int i, c;
1.16         (drh      13-Sep-06):   switch( *z ){
1.16         (drh      13-Sep-06):     case 0: {
1.16         (drh      13-Sep-06):       *tokenType = TOKEN_EOF;
1.16         (drh      13-Sep-06):       return 0;
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):     case ' ': case '\t': case '\n': case '\f': case '\r': {
1.16         (drh      13-Sep-06):       for(i=1; isspace(z[i]); i++){}
1.16         (drh      13-Sep-06):       *tokenType = TOKEN_SPACE;
1.16         (drh      13-Sep-06):       return i;
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):     case '\'':
1.16         (drh      13-Sep-06):     case '"': {
1.16         (drh      13-Sep-06):       int delim = z[0];
1.16         (drh      13-Sep-06):       for(i=1; (c=z[i])!=0; i++){
1.16         (drh      13-Sep-06):         if( c==delim ){
1.16         (drh      13-Sep-06):           if( z[i+1]==delim ){
1.16         (drh      13-Sep-06):             i++;
1.16         (drh      13-Sep-06):           }else{
1.16         (drh      13-Sep-06):             break;
1.16         (drh      13-Sep-06):           }
1.16         (drh      13-Sep-06):         }
1.16         (drh      13-Sep-06):       }
1.16         (drh      13-Sep-06):       *tokenType = TOKEN_STRING;
1.16         (drh      13-Sep-06):       return i + (c!=0);
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):     case '[': {
1.16         (drh      13-Sep-06):       for(i=1, c=z[0]; c!=']' && (c=z[i])!=0; i++){}
1.16         (drh      13-Sep-06):       *tokenType = TOKEN_ID;
1.16         (drh      13-Sep-06):       return i;
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):     default: {
1.16         (drh      13-Sep-06):       if( !IdChar(*z) ){
1.16         (drh      13-Sep-06):         break;
1.16         (drh      13-Sep-06):       }
1.16         (drh      13-Sep-06):       for(i=1; IdChar(z[i]); i++){}
1.16         (drh      13-Sep-06):       *tokenType = TOKEN_ID;
1.16         (drh      13-Sep-06):       return i;
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   *tokenType = TOKEN_PUNCT;
1.14         (adamd    13-Sep-06):   return 1;
1.14         (adamd    13-Sep-06): }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** A token extracted from a string is an instance of the following
1.16         (drh      13-Sep-06): ** structure.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): typedef struct Token {
1.16         (drh      13-Sep-06):   const char *z;       /* Pointer to token text.  Not '\000' terminated */
1.16         (drh      13-Sep-06):   short int n;         /* Length of the token text in bytes. */
1.16         (drh      13-Sep-06): } Token;
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Given a input string (which is really one of the argv[] parameters
1.16         (drh      13-Sep-06): ** passed into xConnect or xCreate) split the string up into tokens.
1.16         (drh      13-Sep-06): ** Return an array of pointers to '\000' terminated strings, one string
1.16         (drh      13-Sep-06): ** for each non-whitespace token.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** The returned array is terminated by a single NULL pointer.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** Space to hold the returned array is obtained from a single
1.16         (drh      13-Sep-06): ** malloc and should be freed by passing the return value to free().
1.16         (drh      13-Sep-06): ** The individual strings within the token list are all a part of
1.16         (drh      13-Sep-06): ** the single memory allocation and will all be freed at once.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static char **tokenizeString(const char *z, int *pnToken){
1.16         (drh      13-Sep-06):   int nToken = 0;
1.16         (drh      13-Sep-06):   Token *aToken = malloc( strlen(z) * sizeof(aToken[0]) );
1.16         (drh      13-Sep-06):   int n = 1;
1.16         (drh      13-Sep-06):   int e, i;
1.16         (drh      13-Sep-06):   int totalSize = 0;
1.16         (drh      13-Sep-06):   char **azToken;
1.16         (drh      13-Sep-06):   char *zCopy;
1.16         (drh      13-Sep-06):   while( n>0 ){
1.16         (drh      13-Sep-06):     n = getToken(z, &e);
1.16         (drh      13-Sep-06):     if( e!=TOKEN_SPACE ){
1.16         (drh      13-Sep-06):       aToken[nToken].z = z;
1.16         (drh      13-Sep-06):       aToken[nToken].n = n;
1.16         (drh      13-Sep-06):       nToken++;
1.16         (drh      13-Sep-06):       totalSize += n+1;
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):     z += n;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   azToken = (char**)malloc( nToken*sizeof(char*) + totalSize );
1.16         (drh      13-Sep-06):   zCopy = (char*)&azToken[nToken];
1.16         (drh      13-Sep-06):   nToken--;
1.16         (drh      13-Sep-06):   for(i=0; i<nToken; i++){
1.16         (drh      13-Sep-06):     azToken[i] = zCopy;
1.16         (drh      13-Sep-06):     n = aToken[i].n;
1.16         (drh      13-Sep-06):     memcpy(zCopy, aToken[i].z, n);
1.16         (drh      13-Sep-06):     zCopy[n] = 0;
1.16         (drh      13-Sep-06):     zCopy += n+1;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   azToken[nToken] = 0;
1.16         (drh      13-Sep-06):   free(aToken);
1.16         (drh      13-Sep-06):   *pnToken = nToken;
1.16         (drh      13-Sep-06):   return azToken;
1.16         (drh      13-Sep-06): }
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Convert an SQL-style quoted string into a normal string by removing
1.16         (drh      13-Sep-06): ** the quote characters.  The conversion is done in-place.  If the
1.16         (drh      13-Sep-06): ** input does not begin with a quote character, then this routine
1.16         (drh      13-Sep-06): ** is a no-op.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** Examples:
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): **     "abc"   becomes   abc
1.16         (drh      13-Sep-06): **     'xyz'   becomes   xyz
1.16         (drh      13-Sep-06): **     [pqr]   becomes   pqr
1.16         (drh      13-Sep-06): **     `mno`   becomes   mno
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): void dequoteString(char *z){
1.16         (drh      13-Sep-06):   int quote;
1.16         (drh      13-Sep-06):   int i, j;
1.16         (drh      13-Sep-06):   if( z==0 ) return;
1.16         (drh      13-Sep-06):   quote = z[0];
1.16         (drh      13-Sep-06):   switch( quote ){
1.16         (drh      13-Sep-06):     case '\'':  break;
1.16         (drh      13-Sep-06):     case '"':   break;
1.16         (drh      13-Sep-06):     case '`':   break;                /* For MySQL compatibility */
1.16         (drh      13-Sep-06):     case '[':   quote = ']';  break;  /* For MS SqlServer compatibility */
1.16         (drh      13-Sep-06):     default:    return;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   for(i=1, j=0; z[i]; i++){
1.16         (drh      13-Sep-06):     if( z[i]==quote ){
1.16         (drh      13-Sep-06):       if( z[i+1]==quote ){
1.16         (drh      13-Sep-06):         z[j++] = quote;
1.16         (drh      13-Sep-06):         i++;
1.16         (drh      13-Sep-06):       }else{
1.16         (drh      13-Sep-06):         z[j++] = 0;
1.16         (drh      13-Sep-06):         break;
1.16         (drh      13-Sep-06):       }
1.16         (drh      13-Sep-06):     }else{
1.16         (drh      13-Sep-06):       z[j++] = z[i];
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06): }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** The input azIn is a NULL-terminated list of tokens.  Remove the first
1.16         (drh      13-Sep-06): ** token and all punctuation tokens.  Remove the quotes from
1.16         (drh      13-Sep-06): ** around string literal tokens.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** Example:
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): **     input:      tokenize chinese ( 'simplifed' , 'mixed' )
1.16         (drh      13-Sep-06): **     output:     chinese simplifed mixed
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** Another example:
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): **     input:      delimiters ( '[' , ']' , '...' )
1.16         (drh      13-Sep-06): **     output:     [ ] ...
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): void tokenListToIdList(char **azIn){
1.16         (drh      13-Sep-06):   int i, j;
1.16         (drh      13-Sep-06):   if( azIn ){
1.16         (drh      13-Sep-06):     for(i=0, j=-1; azIn[i]; i++){
1.16         (drh      13-Sep-06):       if( isalnum(azIn[i][0]) || azIn[i][1] ){
1.16         (drh      13-Sep-06):         dequoteString(azIn[i]);
1.16         (drh      13-Sep-06):         if( j>=0 ){
1.16         (drh      13-Sep-06):           azIn[j] = azIn[i];
1.16         (drh      13-Sep-06):         }
1.16         (drh      13-Sep-06):         j++;
1.16         (drh      13-Sep-06):       }
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):     azIn[j] = 0;
1.16         (drh      13-Sep-06):   }
1.14         (adamd    13-Sep-06): }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Find the first alphanumeric token in the string zIn.  Null-terminate
1.16         (drh      13-Sep-06): ** this token.  Remove any quotation marks.  And return a pointer to
1.16         (drh      13-Sep-06): ** the result.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static char *firstToken(char *zIn, char **pzTail){
1.16         (drh      13-Sep-06):   int i, n, ttype;
1.16         (drh      13-Sep-06):   i = 0;
1.16         (drh      13-Sep-06):   while(1){
1.16         (drh      13-Sep-06):     n = getToken(zIn, &ttype);
1.16         (drh      13-Sep-06):     if( ttype==TOKEN_SPACE ){
1.16         (drh      13-Sep-06):       zIn += n;
1.16         (drh      13-Sep-06):     }else if( ttype==TOKEN_EOF ){
1.16         (drh      13-Sep-06):       *pzTail = zIn;
1.16         (drh      13-Sep-06):       return 0;
1.16         (drh      13-Sep-06):     }else{
1.16         (drh      13-Sep-06):       zIn[n] = 0;
1.16         (drh      13-Sep-06):       *pzTail = &zIn[1];
1.16         (drh      13-Sep-06):       dequoteString(zIn);
1.16         (drh      13-Sep-06):       return zIn;
1.16         (drh      13-Sep-06):     }
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   /*NOTREACHED*/
1.11         (drh      11-Sep-06): }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): /* Return true if...
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): **   *  s begins with the string t, ignoring case
1.16         (drh      13-Sep-06): **   *  s is longer than t
1.16         (drh      13-Sep-06): **   *  The first character of s beyond t is not a alphanumeric
1.16         (drh      13-Sep-06): ** 
1.16         (drh      13-Sep-06): ** Ignore leading space in *s.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** To put it another way, return true if the first token of
1.16         (drh      13-Sep-06): ** s[] is t[].
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static int startsWith(const char *s, const char *t){
1.16         (drh      13-Sep-06):   while( isspace(*s) ){ s++; }
1.16         (drh      13-Sep-06):   while( *t ){
1.16         (drh      13-Sep-06):     if( tolower(*s++)!=tolower(*t++) ) return 0;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   return *s!='_' && !isalnum(*s);
1.16         (drh      13-Sep-06): }
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** An instance of this structure defines the "spec" of a the
1.16         (drh      13-Sep-06): ** full text index.  This structure is populated by parseSpec
1.16         (drh      13-Sep-06): ** and use by fulltextConnect and fulltextCreate.
1.16         (drh      13-Sep-06): */
1.14         (adamd    13-Sep-06): typedef struct TableSpec {
1.16         (drh      13-Sep-06):   const char *zName;       /* Name of the full-text index */
1.16         (drh      13-Sep-06):   int nColumn;             /* Number of columns to be indexed */
1.16         (drh      13-Sep-06):   char **azColumn;         /* Original names of columns to be indexed */
1.16         (drh      13-Sep-06):   char *zColumnList;       /* Comma-separated list of names for %_content */
1.16         (drh      13-Sep-06):   char **azTokenizer;      /* Name of tokenizer and its arguments */
1.14         (adamd    13-Sep-06): } TableSpec;
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Reclaim all of the memory used by a TableSpec
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): void clearTableSpec(TableSpec *p) {
1.16         (drh      13-Sep-06):   free(p->azColumn);
1.16         (drh      13-Sep-06):   free(p->zColumnList);
1.16         (drh      13-Sep-06):   free(p->azTokenizer);
1.11         (drh      11-Sep-06): }
1.11         (drh      11-Sep-06): 
1.14         (adamd    13-Sep-06): /* Parse a CREATE VIRTUAL TABLE statement, which looks like this:
1.14         (adamd    13-Sep-06):  *
1.14         (adamd    13-Sep-06):  * CREATE VIRTUAL TABLE email
1.14         (adamd    13-Sep-06):  *        USING fts1(subject, body, tokenize mytokenizer(myarg))
1.14         (adamd    13-Sep-06):  *
1.14         (adamd    13-Sep-06):  * We return parsed information in a TableSpec structure.
1.14         (adamd    13-Sep-06):  * 
1.14         (adamd    13-Sep-06):  */
1.16         (drh      13-Sep-06): int parseSpec(TableSpec *pSpec, int argc, const char *const*argv, char**pzErr){
1.16         (drh      13-Sep-06):   int i, j, n;
1.16         (drh      13-Sep-06):   char *z, *zDummy;
1.16         (drh      13-Sep-06):   char **azArg;
1.16         (drh      13-Sep-06):   const char *zTokenizer = 0;    /* argv[] entry describing the tokenizer */
1.16         (drh      13-Sep-06): 
1.14         (adamd    13-Sep-06):   assert( argc>=3 );
1.14         (adamd    13-Sep-06):   /* Current interface:
1.14         (adamd    13-Sep-06):   ** argv[0] - module name
1.14         (adamd    13-Sep-06):   ** argv[1] - database name
1.14         (adamd    13-Sep-06):   ** argv[2] - table name
1.14         (adamd    13-Sep-06):   ** argv[3..] - columns, optionally followed by tokenizer specification
1.16         (drh      13-Sep-06):   **             and snippet delimiters specification.
1.14         (adamd    13-Sep-06):   */
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06):   /* Make a copy of the complete argv[][] array in a single allocation.
1.16         (drh      13-Sep-06):   ** The argv[][] array is read-only and transient.  We can write to the
1.16         (drh      13-Sep-06):   ** copy in order to modify things and the copy is persistent.
1.16         (drh      13-Sep-06):   */
1.21         (drh      15-Sep-06):   memset(pSpec, 0, sizeof(*pSpec));
1.16         (drh      13-Sep-06):   for(i=n=0; i<argc; i++){
1.16         (drh      13-Sep-06):     n += strlen(argv[i]) + 1;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   azArg = malloc( sizeof(char*)*argc + n );
1.16         (drh      13-Sep-06):   if( azArg==0 ){
1.16         (drh      13-Sep-06):     return SQLITE_NOMEM;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   z = (char*)&azArg[argc];
1.16         (drh      13-Sep-06):   for(i=0; i<argc; i++){
1.16         (drh      13-Sep-06):     azArg[i] = z;
1.16         (drh      13-Sep-06):     strcpy(z, argv[i]);
1.16         (drh      13-Sep-06):     z += strlen(z)+1;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06):   /* Identify the column names and the tokenizer and delimiter arguments
1.16         (drh      13-Sep-06):   ** in the argv[][] array.
1.16         (drh      13-Sep-06):   */
1.16         (drh      13-Sep-06):   pSpec->zName = azArg[2];
1.16         (drh      13-Sep-06):   pSpec->nColumn = 0;
1.16         (drh      13-Sep-06):   pSpec->azColumn = azArg;
1.16         (drh      13-Sep-06):   zTokenizer = "tokenize simple";
1.16         (drh      13-Sep-06):   n = 0;
1.16         (drh      13-Sep-06):   for(i=3, j=0; i<argc; ++i){
1.16         (drh      13-Sep-06):     if( startsWith(azArg[i],"tokenize") ){
1.16         (drh      13-Sep-06):       zTokenizer = azArg[i];
1.16         (drh      13-Sep-06):     }else{
1.16         (drh      13-Sep-06):       z = azArg[pSpec->nColumn] = firstToken(azArg[i], &zDummy);
1.16         (drh      13-Sep-06):       pSpec->nColumn++;
1.16         (drh      13-Sep-06):       n += strlen(z) + 6;
1.14         (adamd    13-Sep-06):     }
1.11         (drh      11-Sep-06):   }
1.16         (drh      13-Sep-06):   if( pSpec->nColumn==0 ){
1.16         (drh      13-Sep-06):     azArg[0] = "content";
1.16         (drh      13-Sep-06):     pSpec->nColumn = 1;
1.16         (drh      13-Sep-06):   }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06):   /*
1.16         (drh      13-Sep-06):   ** Construct the comma-separated list of column names.
1.16         (drh      13-Sep-06):   **
1.16         (drh      13-Sep-06):   ** Each column name will be of the form cNNAAAA
1.16         (drh      13-Sep-06):   ** where NN is the column number and AAAA is the sanitized
1.16         (drh      13-Sep-06):   ** column name.  "sanitized" means that special characters are
1.16         (drh      13-Sep-06):   ** converted to "_".  The cNN prefix guarantees that all column
1.16         (drh      13-Sep-06):   ** names are unique.
1.16         (drh      13-Sep-06):   **
1.16         (drh      13-Sep-06):   ** The AAAA suffix is not strictly necessary.  It is included
1.16         (drh      13-Sep-06):   ** for the convenience of people who might examine the generated
1.16         (drh      13-Sep-06):   ** %_content table and wonder what the columns are used for.
1.16         (drh      13-Sep-06):   */
1.16         (drh      13-Sep-06):   z = pSpec->zColumnList = malloc( n );
1.16         (drh      13-Sep-06):   if( z==0 ){
1.16         (drh      13-Sep-06):     clearTableSpec(pSpec);
1.16         (drh      13-Sep-06):     return SQLITE_NOMEM;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   for(i=0; i<pSpec->nColumn; i++){
1.16         (drh      13-Sep-06):     sqlite3_snprintf(n, z, "c%d%s", i, azArg[i]);
1.16         (drh      13-Sep-06):     for(j=0; z[j]; j++){
1.16         (drh      13-Sep-06):       if( !isalnum(z[j]) ) z[j] = '_';
1.14         (adamd    13-Sep-06):     }
1.16         (drh      13-Sep-06):     z[j] = ',';
1.16         (drh      13-Sep-06):     z += j+1;
1.14         (adamd    13-Sep-06):   }
1.16         (drh      13-Sep-06):   z[-1] = 0;
1.16         (drh      13-Sep-06): 
1.16         (drh      13-Sep-06):   /*
1.16         (drh      13-Sep-06):   ** Parse the tokenizer specification string.
1.16         (drh      13-Sep-06):   */
1.16         (drh      13-Sep-06):   pSpec->azTokenizer = tokenizeString(zTokenizer, &n);
1.16         (drh      13-Sep-06):   tokenListToIdList(pSpec->azTokenizer);
1.14         (adamd    13-Sep-06): 
1.16         (drh      13-Sep-06):   return SQLITE_OK;
1.14         (adamd    13-Sep-06): }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Generate a CREATE TABLE statement that describes the schema of
1.23         (drh      18-Sep-06): ** the virtual table.  Return a pointer to this schema string.
1.16         (drh      13-Sep-06): **
1.16         (drh      13-Sep-06): ** Space is obtained from sqlite3_mprintf() and should be freed
1.16         (drh      13-Sep-06): ** using sqlite3_free().
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static char *fulltextSchema(
1.16         (drh      13-Sep-06):   int nColumn,                  /* Number of columns */
1.23         (drh      18-Sep-06):   const char *const* azColumn,  /* List of columns */
1.23         (drh      18-Sep-06):   const char *zTableName        /* Name of the table */
1.16         (drh      13-Sep-06): ){
1.14         (adamd    13-Sep-06):   int i;
1.16         (drh      13-Sep-06):   char *zSchema, *zNext;
1.16         (drh      13-Sep-06):   const char *zSep = "(";
1.16         (drh      13-Sep-06):   zSchema = sqlite3_mprintf("CREATE TABLE x");
1.16         (drh      13-Sep-06):   for(i=0; i<nColumn; i++){
1.16         (drh      13-Sep-06):     zNext = sqlite3_mprintf("%s%s%Q", zSchema, zSep, azColumn[i]);
1.16         (drh      13-Sep-06):     sqlite3_free(zSchema);
1.16         (drh      13-Sep-06):     zSchema = zNext;
1.16         (drh      13-Sep-06):     zSep = ",";
1.16         (drh      13-Sep-06):   }
1.23         (drh      18-Sep-06):   zNext = sqlite3_mprintf("%s,%Q)", zSchema, zTableName);
1.16         (drh      13-Sep-06):   sqlite3_free(zSchema);
1.16         (drh      13-Sep-06):   return zNext;
1.14         (adamd    13-Sep-06): }
1.11         (drh      11-Sep-06): 
1.16         (drh      13-Sep-06): /*
1.16         (drh      13-Sep-06): ** Build a new sqlite3_vtab structure that will describe the
1.16         (drh      13-Sep-06): ** fulltext index defined by spec.
1.16         (drh      13-Sep-06): */
1.16         (drh      13-Sep-06): static int constructVtab(
1.16         (drh      13-Sep-06):   sqlite3 *db,              /* The SQLite database connection */
1.16         (drh      13-Sep-06):   TableSpec *spec,          /* Parsed spec information from parseSpec() */
1.16         (drh      13-Sep-06):   sqlite3_vtab **ppVTab,    /* Write the resulting vtab structure here */
1.16         (drh      13-Sep-06):   char **pzErr              /* Write any error message here */
1.16         (drh      13-Sep-06): ){
1.14         (adamd    13-Sep-06):   int rc;
1.16         (drh      13-Sep-06):   int n;
1.11         (drh      11-Sep-06):   fulltext_vtab *v = 0;
1.4          (drh      02-Sep-06):   const sqlite3_tokenizer_module *m = NULL;
1.14         (adamd    13-Sep-06):   char *schema;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   v = (fulltext_vtab *) malloc(sizeof(fulltext_vtab));
1.16         (drh      13-Sep-06):   if( v==0 ) return SQLITE_NOMEM;
1.10         (drh      10-Sep-06):   memset(v, 0, sizeof(*v));
1.14         (adamd    13-Sep-06):   /* sqlite will initialize v->base */
1.1          (drh      31-Aug-06):   v->db = db;
1.16         (drh      13-Sep-06):   v->zName = spec->zName;   /* Freed when azColumn is freed */
1.16         (drh      13-Sep-06):   v->nColumn = spec->nColumn;
1.16         (drh      13-Sep-06):   v->zColumnList = spec->zColumnList;
1.16         (drh      13-Sep-06):   spec->zColumnList = 0;
1.16         (drh      13-Sep-06):   v->azColumn = spec->azColumn;
1.16         (drh      13-Sep-06):   spec->azColumn = 0;
1.1          (drh      31-Aug-06): 
1.16         (drh      13-Sep-06):   if( spec->azTokenizer==0 ){
1.16         (drh      13-Sep-06):     return SQLITE_NOMEM;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   /* TODO(shess) For now, add new tokenizers as else if clauses. */
1.16         (drh      13-Sep-06):   if( spec->azTokenizer[0]==0 || !strcmp(spec->azTokenizer[0], "simple") ){
1.14         (adamd    13-Sep-06):     sqlite3Fts1SimpleTokenizerModule(&m);
1.14         (adamd    13-Sep-06):   } else {
1.16         (drh      13-Sep-06):     *pzErr = sqlite3_mprintf("unknown tokenizer: %s", spec->azTokenizer[0]);
1.16         (drh      13-Sep-06):     rc = SQLITE_ERROR;
1.16         (drh      13-Sep-06):     goto err;
1.16         (drh      13-Sep-06):   }
1.16         (drh      13-Sep-06):   for(n=0; spec->azTokenizer[n]; n++){}
1.16         (drh      13-Sep-06):   if( n ){
1.16         (drh      13-Sep-06):     rc = m->xCreate(n-1, (const char*const*)&spec->azTokenizer[1],
1.16         (drh      13-Sep-06):                     &v->pTokenizer);
1.16         (drh      13-Sep-06):   }else{
1.16         (drh      13-Sep-06):     rc = m->xCreate(0, 0, &v->pTokenizer);
1.1          (drh      31-Aug-06):   }
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) goto err;
1.14         (adamd    13-Sep-06):   v->pTokenizer->pModule = m;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* TODO: verify the existence of backing tables foo_content, foo_term */
1.1          (drh      31-Aug-06): 
1.23         (drh      18-Sep-06):   schema = fulltextSchema(v->nColumn, (const char*const*)v->azColumn,
1.23         (drh      18-Sep-06):                           spec->zName);
1.14         (adamd    13-Sep-06):   rc = sqlite3_declare_vtab(db, schema);
1.16         (drh      13-Sep-06):   sqlite3_free(schema);
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) goto err;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   memset(v->pFulltextStatements, 0, sizeof(v->pFulltextStatements));
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   *ppVTab = &v->base;
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Connect %p\n", v));
1.11         (drh      11-Sep-06): 
1.14         (adamd    13-Sep-06):   return rc;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06): err:
1.14         (adamd    13-Sep-06):   fulltext_vtab_destroy(v);
1.14         (adamd    13-Sep-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): static int fulltextConnect(
1.14         (adamd    13-Sep-06):   sqlite3 *db,
1.14         (adamd    13-Sep-06):   void *pAux,
1.14         (adamd    13-Sep-06):   int argc, const char *const*argv,
1.14         (adamd    13-Sep-06):   sqlite3_vtab **ppVTab,
1.14         (adamd    13-Sep-06):   char **pzErr
1.14         (adamd    13-Sep-06): ){
1.14         (adamd    13-Sep-06):   TableSpec spec;
1.16         (drh      13-Sep-06):   int rc = parseSpec(&spec, argc, argv, pzErr);
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) return rc;
1.14         (adamd    13-Sep-06): 
1.16         (drh      13-Sep-06):   rc = constructVtab(db, &spec, ppVTab, pzErr);
1.16         (drh      13-Sep-06):   clearTableSpec(&spec);
1.14         (adamd    13-Sep-06):   return rc;
1.14         (adamd    13-Sep-06): }
1.1          (drh      31-Aug-06): 
1.15         (drh      13-Sep-06):   /* The %_content table holds the text of each document, with
1.1          (drh      31-Aug-06):   ** the rowid used as the docid.
1.1          (drh      31-Aug-06):   **
1.1          (drh      31-Aug-06):   ** The %_term table maps each term to a document list blob
1.1          (drh      31-Aug-06):   ** containing elements sorted by ascending docid, each element
1.1          (drh      31-Aug-06):   ** encoded as:
1.1          (drh      31-Aug-06):   **
1.1          (drh      31-Aug-06):   **   docid varint-encoded
1.7          (shess    08-Sep-06):   **   token elements:
1.7          (shess    08-Sep-06):   **     position+1 varint-encoded as delta from previous position
1.1          (drh      31-Aug-06):   **     start offset varint-encoded as delta from previous start offset
1.1          (drh      31-Aug-06):   **     end offset varint-encoded as delta from start offset
1.1          (drh      31-Aug-06):   **
1.7          (shess    08-Sep-06):   ** The sentinel position of 0 indicates the end of the token list.
1.7          (shess    08-Sep-06):   **
1.7          (shess    08-Sep-06):   ** Additionally, doclist blobs are chunked into multiple segments,
1.7          (shess    08-Sep-06):   ** using segment to order the segments.  New elements are added to
1.7          (shess    08-Sep-06):   ** the segment at segment 0, until it exceeds CHUNK_MAX.  Then
1.7          (shess    08-Sep-06):   ** segment 0 is deleted, and the doclist is inserted at segment 1.
1.7          (shess    08-Sep-06):   ** If there is already a doclist at segment 1, the segment 0 doclist
1.7          (shess    08-Sep-06):   ** is merged with it, the segment 1 doclist is deleted, and the
1.7          (shess    08-Sep-06):   ** merged doclist is inserted at segment 2, repeating those
1.7          (shess    08-Sep-06):   ** operations until an insert succeeds.
1.7          (shess    08-Sep-06):   **
1.7          (shess    08-Sep-06):   ** Since this structure doesn't allow us to update elements in place
1.7          (shess    08-Sep-06):   ** in case of deletion or update, these are simply written to
1.7          (shess    08-Sep-06):   ** segment 0 (with an empty token list in case of deletion), with
1.7          (shess    08-Sep-06):   ** docListAccumulate() taking care to retain lower-segment
1.7          (shess    08-Sep-06):   ** information in preference to higher-segment information.
1.1          (drh      31-Aug-06):   */
1.7          (shess    08-Sep-06):   /* TODO(shess) Provide a VACUUM type operation which both removes
1.7          (shess    08-Sep-06):   ** deleted elements which are no longer necessary, and duplicated
1.7          (shess    08-Sep-06):   ** elements.  I suspect this will probably not be necessary in
1.7          (shess    08-Sep-06):   ** practice, though.
1.1          (drh      31-Aug-06):   */
1.14         (adamd    13-Sep-06): static int fulltextCreate(sqlite3 *db, void *pAux,
1.14         (adamd    13-Sep-06):                           int argc, const char * const *argv,
1.14         (adamd    13-Sep-06):                           sqlite3_vtab **ppVTab, char **pzErr){
1.14         (adamd    13-Sep-06):   int rc;
1.14         (adamd    13-Sep-06):   TableSpec spec;
1.14         (adamd    13-Sep-06):   char *schema;
1.14         (adamd    13-Sep-06):   TRACE(("FTS1 Create\n"));
1.14         (adamd    13-Sep-06): 
1.16         (drh      13-Sep-06):   rc = parseSpec(&spec, argc, argv, pzErr);
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) return rc;
1.14         (adamd    13-Sep-06): 
1.16         (drh      13-Sep-06):   schema = sqlite3_mprintf("CREATE TABLE %%_content(%s)", spec.zColumnList);
1.14         (adamd    13-Sep-06):   rc = sql_exec(db, spec.zName, schema);
1.16         (drh      13-Sep-06):   sqlite3_free(schema);
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) goto out;
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   rc = sql_exec(db, spec.zName,
1.7          (shess    08-Sep-06):     "create table %_term(term text, segment integer, doclist blob, "
1.7          (shess    08-Sep-06):                         "primary key(term, segment));");
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) goto out;
1.14         (adamd    13-Sep-06): 
1.16         (drh      13-Sep-06):   rc = constructVtab(db, &spec, ppVTab, pzErr);
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): out:
1.16         (drh      13-Sep-06):   clearTableSpec(&spec);
1.14         (adamd    13-Sep-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): /* Decide how to handle an SQL query. */
1.1          (drh      31-Aug-06): static int fulltextBestIndex(sqlite3_vtab *pVTab, sqlite3_index_info *pInfo){
1.1          (drh      31-Aug-06):   int i;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   for(i=0; i<pInfo->nConstraint; ++i){
1.1          (drh      31-Aug-06):     const struct sqlite3_index_constraint *pConstraint;
1.1          (drh      31-Aug-06):     pConstraint = &pInfo->aConstraint[i];
1.13         (adamd    12-Sep-06):     if( pConstraint->usable ) {
1.13         (adamd    12-Sep-06):       if( pConstraint->iColumn==-1 &&
1.13         (adamd    12-Sep-06):           pConstraint->op==SQLITE_INDEX_CONSTRAINT_EQ ){
1.13         (adamd    12-Sep-06):         pInfo->idxNum = QUERY_ROWID;      /* lookup by rowid */
1.14         (adamd    13-Sep-06):       } else if( pConstraint->iColumn>=0 &&
1.13         (adamd    12-Sep-06):                  pConstraint->op==SQLITE_INDEX_CONSTRAINT_MATCH ){
1.14         (adamd    13-Sep-06):         /* full-text search */
1.14         (adamd    13-Sep-06):         pInfo->idxNum = QUERY_FULLTEXT + pConstraint->iColumn;
1.13         (adamd    12-Sep-06):       } else continue;
1.13         (adamd    12-Sep-06): 
1.1          (drh      31-Aug-06):       pInfo->aConstraintUsage[i].argvIndex = 1;
1.1          (drh      31-Aug-06):       pInfo->aConstraintUsage[i].omit = 1;
1.13         (adamd    12-Sep-06): 
1.13         (adamd    12-Sep-06):       /* An arbitrary value for now.
1.13         (adamd    12-Sep-06):        * TODO: Perhaps rowid matches should be considered cheaper than
1.13         (adamd    12-Sep-06):        * full-text searches. */
1.13         (adamd    12-Sep-06):       pInfo->estimatedCost = 1.0;   
1.13         (adamd    12-Sep-06): 
1.1          (drh      31-Aug-06):       return SQLITE_OK;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   pInfo->idxNum = QUERY_GENERIC;
1.5          (drh      02-Sep-06):   TRACE(("FTS1 BestIndex\n"));
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int fulltextDisconnect(sqlite3_vtab *pVTab){
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Disconnect %p\n", pVTab));
1.1          (drh      31-Aug-06):   fulltext_vtab_destroy((fulltext_vtab *)pVTab);
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int fulltextDestroy(sqlite3_vtab *pVTab){
1.1          (drh      31-Aug-06):   fulltext_vtab *v = (fulltext_vtab *)pVTab;
1.6          (adamd    05-Sep-06):   int rc;
1.1          (drh      31-Aug-06): 
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Destroy %p\n", pVTab));
1.6          (adamd    05-Sep-06):   rc = sql_exec(v->db, v->zName,
1.1          (drh      31-Aug-06):                     "drop table %_content; drop table %_term");
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   fulltext_vtab_destroy((fulltext_vtab *)pVTab);
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int fulltextOpen(sqlite3_vtab *pVTab, sqlite3_vtab_cursor **ppCursor){
1.1          (drh      31-Aug-06):   fulltext_cursor *c;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   c = (fulltext_cursor *) calloc(sizeof(fulltext_cursor), 1);
1.1          (drh      31-Aug-06):   /* sqlite will initialize c->base */
1.1          (drh      31-Aug-06):   *ppCursor = &c->base;
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Open %p: %p\n", pVTab, c));
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.19         (drh      13-Sep-06): 
1.19         (drh      13-Sep-06): /* Free all of the dynamically allocated memory held by *q
1.19         (drh      13-Sep-06): */
1.19         (drh      13-Sep-06): static void queryClear(Query *q){
1.19         (drh      13-Sep-06):   int i;
1.19         (drh      13-Sep-06):   for(i = 0; i < q->nTerms; ++i){
1.19         (drh      13-Sep-06):     free(q->pTerms[i].pTerm);
1.19         (drh      13-Sep-06):   }
1.19         (drh      13-Sep-06):   free(q->pTerms);
1.19         (drh      13-Sep-06):   memset(q, 0, sizeof(*q));
1.19         (drh      13-Sep-06): }
1.19         (drh      13-Sep-06): 
1.20         (drh      14-Sep-06): /* Free all of the dynamically allocated memory held by the
1.20         (drh      14-Sep-06): ** Snippet
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): static void snippetClear(Snippet *p){
1.20         (drh      14-Sep-06):   free(p->aMatch);
1.20         (drh      14-Sep-06):   free(p->zOffset);
1.26         (drh      21-Sep-06):   free(p->zSnippet);
1.20         (drh      14-Sep-06):   memset(p, 0, sizeof(*p));
1.20         (drh      14-Sep-06): }
1.20         (drh      14-Sep-06): /*
1.20         (drh      14-Sep-06): ** Append a single entry to the p->aMatch[] log.
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): static void snippetAppendMatch(
1.20         (drh      14-Sep-06):   Snippet *p,               /* Append the entry to this snippet */
1.20         (drh      14-Sep-06):   int iCol, int iTerm,      /* The column and query term */
1.20         (drh      14-Sep-06):   int iStart, int nByte     /* Offset and size of the match */
1.20         (drh      14-Sep-06): ){
1.20         (drh      14-Sep-06):   int i;
1.22         (drh      16-Sep-06):   struct snippetMatch *pMatch;
1.20         (drh      14-Sep-06):   if( p->nMatch+1>=p->nAlloc ){
1.20         (drh      14-Sep-06):     p->nAlloc = p->nAlloc*2 + 10;
1.20         (drh      14-Sep-06):     p->aMatch = realloc(p->aMatch, p->nAlloc*sizeof(p->aMatch[0]) );
1.20         (drh      14-Sep-06):     if( p->aMatch==0 ){
1.20         (drh      14-Sep-06):       p->nMatch = 0;
1.20         (drh      14-Sep-06):       p->nAlloc = 0;
1.20         (drh      14-Sep-06):       return;
1.20         (drh      14-Sep-06):     }
1.20         (drh      14-Sep-06):   }
1.20         (drh      14-Sep-06):   i = p->nMatch++;
1.22         (drh      16-Sep-06):   pMatch = &p->aMatch[i];
1.22         (drh      16-Sep-06):   pMatch->iCol = iCol;
1.22         (drh      16-Sep-06):   pMatch->iTerm = iTerm;
1.22         (drh      16-Sep-06):   pMatch->iStart = iStart;
1.22         (drh      16-Sep-06):   pMatch->nByte = nByte;
1.20         (drh      14-Sep-06): }
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06): /*
1.20         (drh      14-Sep-06): ** Sizing information for the circular buffer used in snippetOffsetsOfColumn()
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): #define FTS1_ROTOR_SZ   (32)
1.20         (drh      14-Sep-06): #define FTS1_ROTOR_MASK (FTS1_ROTOR_SZ-1)
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06): /*
1.20         (drh      14-Sep-06): ** Add entries to pSnippet->aMatch[] for every match that occurs against
1.20         (drh      14-Sep-06): ** document zDoc[0..nDoc-1] which is stored in column iColumn.
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): static void snippetOffsetsOfColumn(
1.20         (drh      14-Sep-06):   Query *pQuery,
1.20         (drh      14-Sep-06):   Snippet *pSnippet,
1.20         (drh      14-Sep-06):   int iColumn,
1.20         (drh      14-Sep-06):   const char *zDoc,
1.20         (drh      14-Sep-06):   int nDoc
1.20         (drh      14-Sep-06): ){
1.20         (drh      14-Sep-06):   const sqlite3_tokenizer_module *pTModule;  /* The tokenizer module */
1.20         (drh      14-Sep-06):   sqlite3_tokenizer *pTokenizer;             /* The specific tokenizer */
1.20         (drh      14-Sep-06):   sqlite3_tokenizer_cursor *pTCursor;        /* Tokenizer cursor */
1.20         (drh      14-Sep-06):   fulltext_vtab *pVtab;                /* The full text index */
1.20         (drh      14-Sep-06):   int nColumn;                         /* Number of columns in the index */
1.20         (drh      14-Sep-06):   const QueryTerm *aTerm;              /* Query string terms */
1.20         (drh      14-Sep-06):   int nTerm;                           /* Number of query string terms */  
1.20         (drh      14-Sep-06):   int i, j;                            /* Loop counters */
1.20         (drh      14-Sep-06):   int rc;                              /* Return code */
1.20         (drh      14-Sep-06):   unsigned int match, prevMatch;       /* Phrase search bitmasks */
1.20         (drh      14-Sep-06):   const char *zToken;                  /* Next token from the tokenizer */
1.20         (drh      14-Sep-06):   int nToken;                          /* Size of zToken */
1.20         (drh      14-Sep-06):   int iBegin, iEnd, iPos;              /* Offsets of beginning and end */
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06):   /* The following variables keep a circular buffer of the last
1.20         (drh      14-Sep-06):   ** few tokens */
1.20         (drh      14-Sep-06):   unsigned int iRotor = 0;             /* Index of current token */
1.20         (drh      14-Sep-06):   int iRotorBegin[FTS1_ROTOR_SZ];      /* Beginning offset of token */
1.20         (drh      14-Sep-06):   int iRotorLen[FTS1_ROTOR_SZ];        /* Length of token */
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06):   pVtab = pQuery->pFts;
1.20         (drh      14-Sep-06):   nColumn = pVtab->nColumn;
1.20         (drh      14-Sep-06):   pTokenizer = pVtab->pTokenizer;
1.20         (drh      14-Sep-06):   pTModule = pTokenizer->pModule;
1.20         (drh      14-Sep-06):   rc = pTModule->xOpen(pTokenizer, zDoc, nDoc, &pTCursor);
1.20         (drh      14-Sep-06):   if( rc ) return;
1.20         (drh      14-Sep-06):   pTCursor->pTokenizer = pTokenizer;
1.20         (drh      14-Sep-06):   aTerm = pQuery->pTerms;
1.20         (drh      14-Sep-06):   nTerm = pQuery->nTerms;
1.20         (drh      14-Sep-06):   if( nTerm>=FTS1_ROTOR_SZ ){
1.20         (drh      14-Sep-06):     nTerm = FTS1_ROTOR_SZ - 1;
1.20         (drh      14-Sep-06):   }
1.20         (drh      14-Sep-06):   prevMatch = 0;
1.20         (drh      14-Sep-06):   while(1){
1.20         (drh      14-Sep-06):     rc = pTModule->xNext(pTCursor, &zToken, &nToken, &iBegin, &iEnd, &iPos);
1.20         (drh      14-Sep-06):     if( rc ) break;
1.20         (drh      14-Sep-06):     iRotorBegin[iRotor&FTS1_ROTOR_MASK] = iBegin;
1.20         (drh      14-Sep-06):     iRotorLen[iRotor&FTS1_ROTOR_MASK] = iEnd-iBegin;
1.20         (drh      14-Sep-06):     match = 0;
1.20         (drh      14-Sep-06):     for(i=0; i<nTerm; i++){
1.20         (drh      14-Sep-06):       int iCol;
1.20         (drh      14-Sep-06):       iCol = aTerm[i].iColumn;
1.20         (drh      14-Sep-06):       if( iCol>=0 && iCol<nColumn && iCol!=iColumn ) continue;
1.20         (drh      14-Sep-06):       if( aTerm[i].nTerm!=nToken ) continue;
1.20         (drh      14-Sep-06):       if( memcmp(aTerm[i].pTerm, zToken, nToken) ) continue;
1.20         (drh      14-Sep-06):       if( aTerm[i].iPhrase>1 && (prevMatch & (1<<i))==0 ) continue;
1.20         (drh      14-Sep-06):       match |= 1<<i;
1.20         (drh      14-Sep-06):       if( i==nTerm-1 || aTerm[i+1].iPhrase==1 ){
1.20         (drh      14-Sep-06):         for(j=aTerm[i].iPhrase-1; j>=0; j--){
1.20         (drh      14-Sep-06):           int k = (iRotor-j) & FTS1_ROTOR_MASK;
1.20         (drh      14-Sep-06):           snippetAppendMatch(pSnippet, iColumn, i-j,
1.20         (drh      14-Sep-06):                 iRotorBegin[k], iRotorLen[k]);
1.20         (drh      14-Sep-06):         }
1.20         (drh      14-Sep-06):       }
1.20         (drh      14-Sep-06):     }
1.20         (drh      14-Sep-06):     prevMatch = match<<1;
1.20         (drh      14-Sep-06):     iRotor++;
1.20         (drh      14-Sep-06):   }
1.20         (drh      14-Sep-06):   pTModule->xClose(pTCursor);  
1.20         (drh      14-Sep-06): }
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06): /*
1.20         (drh      14-Sep-06): ** Compute all offsets for the current row of the query.  
1.20         (drh      14-Sep-06): ** If the offsets have already been computed, this routine is a no-op.
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): static void snippetAllOffsets(fulltext_cursor *p){
1.20         (drh      14-Sep-06):   int nColumn;
1.20         (drh      14-Sep-06):   int iColumn, i;
1.20         (drh      14-Sep-06):   int iFirst, iLast;
1.20         (drh      14-Sep-06):   fulltext_vtab *pFts;
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06):   if( p->snippet.nMatch ) return;
1.20         (drh      14-Sep-06):   if( p->q.nTerms==0 ) return;
1.20         (drh      14-Sep-06):   pFts = p->q.pFts;
1.20         (drh      14-Sep-06):   nColumn = pFts->nColumn;
1.20         (drh      14-Sep-06):   iColumn = p->iCursorType;
1.20         (drh      14-Sep-06):   if( iColumn<0 || iColumn>=nColumn ){
1.20         (drh      14-Sep-06):     iFirst = 0;
1.20         (drh      14-Sep-06):     iLast = nColumn-1;
1.20         (drh      14-Sep-06):   }else{
1.20         (drh      14-Sep-06):     iFirst = iColumn;
1.20         (drh      14-Sep-06):     iLast = iColumn;
1.20         (drh      14-Sep-06):   }
1.20         (drh      14-Sep-06):   for(i=iFirst; i<=iLast; i++){
1.20         (drh      14-Sep-06):     const char *zDoc;
1.20         (drh      14-Sep-06):     int nDoc;
1.20         (drh      14-Sep-06):     zDoc = (const char*)sqlite3_column_text(p->pStmt, i+1);
1.20         (drh      14-Sep-06):     nDoc = sqlite3_column_bytes(p->pStmt, i+1);
1.20         (drh      14-Sep-06):     snippetOffsetsOfColumn(&p->q, &p->snippet, i, zDoc, nDoc);
1.20         (drh      14-Sep-06):   }
1.20         (drh      14-Sep-06): }
1.20         (drh      14-Sep-06): 
1.20         (drh      14-Sep-06): /*
1.20         (drh      14-Sep-06): ** Convert the information in the aMatch[] array of the snippet
1.20         (drh      14-Sep-06): ** into the string zOffset[0..nOffset-1].
1.20         (drh      14-Sep-06): */
1.20         (drh      14-Sep-06): static void snippetOffsetText(Snippet *p){
1.20         (drh      14-Sep-06):   int i;
1.22         (drh      16-Sep-06):   int cnt = 0;
1.20         (drh      14-Sep-06):   StringBuffer sb;
1.20         (drh      14-Sep-06):   char zBuf[200];
1.20         (drh      14-Sep-06):   if( p->zOffset ) return;
1.20         (drh      14-Sep-06):   initStringBuffer(&sb);
1.20         (drh      14-Sep-06):   for(i=0; i<p->nMatch; i++){
1.22         (drh      16-Sep-06):     struct snippetMatch *pMatch = &p->aMatch[i];
1.20         (drh      14-Sep-06):     zBuf[0] = ' ';
1.22         (drh      16-Sep-06):     sprintf(&zBuf[cnt>0], "%d %d %d %d", pMatch->iCol,
1.22         (drh      16-Sep-06):         pMatch->iTerm, pMatch->iStart, pMatch->nByte);
1.20         (drh      14-Sep-06):     append(&sb, zBuf);
1.22         (drh      16-Sep-06):     cnt++;
1.20         (drh      14-Sep-06):   }
1.20         (drh      14-Sep-06):   p->zOffset = sb.s;
1.20         (drh      14-Sep-06):   p->nOffset = sb.len;
1.20         (drh      14-Sep-06): }
1.20         (drh      14-Sep-06): 
1.19         (drh      13-Sep-06): /*
1.26         (drh      21-Sep-06): ** zDoc[0..nDoc-1] is phrase of text.  aMatch[0..nMatch-1] are a set
1.26         (drh      21-Sep-06): ** of matching words some of which might be in zDoc.  zDoc is column
1.26         (drh      21-Sep-06): ** number iCol.
1.26         (drh      21-Sep-06): **
1.26         (drh      21-Sep-06): ** iBreak is suggested spot in zDoc where we could begin or end an
1.26         (drh      21-Sep-06): ** excerpt.  Return a value similar to iBreak but possibly adjusted
1.26         (drh      21-Sep-06): ** to be a little left or right so that the break point is better.
1.26         (drh      21-Sep-06): */
1.26         (drh      21-Sep-06): static int wordBoundary(
1.26         (drh      21-Sep-06):   int iBreak,                   /* The suggested break point */
1.26         (drh      21-Sep-06):   const char *zDoc,             /* Document text */
1.26         (drh      21-Sep-06):   int nDoc,                     /* Number of bytes in zDoc[] */
1.26         (drh      21-Sep-06):   struct snippetMatch *aMatch,  /* Matching words */
1.26         (drh      21-Sep-06):   int nMatch,                   /* Number of entries in aMatch[] */
1.26         (drh      21-Sep-06):   int iCol                      /* The column number for zDoc[] */
1.26         (drh      21-Sep-06): ){
1.26         (drh      21-Sep-06):   int i;
1.26         (drh      21-Sep-06):   if( iBreak<=10 ){
1.26         (drh      21-Sep-06):     return 0;
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   if( iBreak>=nDoc-10 ){
1.26         (drh      21-Sep-06):     return nDoc;
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   for(i=0; i<nMatch && aMatch[i].iCol<iCol; i++){}
1.26         (drh      21-Sep-06):   while( i<nMatch && aMatch[i].iStart+aMatch[i].nByte<iBreak ){ i++; }
1.26         (drh      21-Sep-06):   if( i<nMatch ){
1.26         (drh      21-Sep-06):     if( aMatch[i].iStart<iBreak+10 ){
1.26         (drh      21-Sep-06):       return aMatch[i].iStart;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     if( i>0 && aMatch[i-1].iStart+aMatch[i-1].nByte>=iBreak ){
1.26         (drh      21-Sep-06):       return aMatch[i-1].iStart;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   for(i=1; i<=10; i++){
1.26         (drh      21-Sep-06):     if( isspace(zDoc[iBreak-i]) ){
1.26         (drh      21-Sep-06):       return iBreak - i + 1;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     if( isspace(zDoc[iBreak+i]) ){
1.26         (drh      21-Sep-06):       return iBreak + i + 1;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   return iBreak;
1.26         (drh      21-Sep-06): }
1.26         (drh      21-Sep-06): 
1.26         (drh      21-Sep-06): /*
1.26         (drh      21-Sep-06): ** Allowed values for Snippet.aMatch[].snStatus
1.26         (drh      21-Sep-06): */
1.26         (drh      21-Sep-06): #define SNIPPET_IGNORE  0   /* It is ok to omit this match from the snippet */
1.26         (drh      21-Sep-06): #define SNIPPET_DESIRED 1   /* We want to include this match in the snippet */  
1.26         (drh      21-Sep-06): 
1.26         (drh      21-Sep-06): /*
1.26         (drh      21-Sep-06): ** Generate the text of a snippet.
1.22         (drh      16-Sep-06): */
1.26         (drh      21-Sep-06): static void snippetText(
1.26         (drh      21-Sep-06):   fulltext_cursor *pCursor,   /* The cursor we need the snippet for */
1.26         (drh      21-Sep-06):   const char *zStartMark,     /* Markup to appear before each match */
1.26         (drh      21-Sep-06):   const char *zEndMark,       /* Markup to appear after each match */
1.26         (drh      21-Sep-06):   const char *zEllipsis       /* Ellipsis mark */
1.26         (drh      21-Sep-06): ){
1.22         (drh      16-Sep-06):   int i, j;
1.26         (drh      21-Sep-06):   struct snippetMatch *aMatch;
1.26         (drh      21-Sep-06):   int nMatch;
1.26         (drh      21-Sep-06):   int nDesired;
1.26         (drh      21-Sep-06):   StringBuffer sb;
1.26         (drh      21-Sep-06):   int tailCol = -1;
1.26         (drh      21-Sep-06):   int tailOffset = -1;
1.26         (drh      21-Sep-06):   int iCol;
1.26         (drh      21-Sep-06):   int nDoc;
1.26         (drh      21-Sep-06):   const char *zDoc;
1.26         (drh      21-Sep-06):   int iStart, iEnd;
1.26         (drh      21-Sep-06):   int wantEllipsis;
1.26         (drh      21-Sep-06):   int tailEllipsis = 0;
1.26         (drh      21-Sep-06):   int iMatch;
1.26         (drh      21-Sep-06):   
1.26         (drh      21-Sep-06): 
1.26         (drh      21-Sep-06):   free(pCursor->snippet.zSnippet);
1.26         (drh      21-Sep-06):   pCursor->snippet.zSnippet = 0;
1.26         (drh      21-Sep-06):   aMatch = pCursor->snippet.aMatch;
1.26         (drh      21-Sep-06):   nMatch = pCursor->snippet.nMatch;
1.26         (drh      21-Sep-06):   initStringBuffer(&sb);
1.26         (drh      21-Sep-06): 
1.26         (drh      21-Sep-06):   for(i=0; i<nMatch; i++){
1.26         (drh      21-Sep-06):     aMatch[i].snStatus = SNIPPET_IGNORE;
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   nDesired = 0;
1.26         (drh      21-Sep-06):   for(i=0; i<pCursor->q.nTerms; i++){
1.26         (drh      21-Sep-06):     for(j=0; j<nMatch; j++){
1.26         (drh      21-Sep-06):       if( aMatch[j].iTerm==i ){
1.26         (drh      21-Sep-06):         aMatch[j].snStatus = SNIPPET_DESIRED;
1.26         (drh      21-Sep-06):         nDesired++;
1.22         (drh      16-Sep-06):         break;
1.22         (drh      16-Sep-06):       }
1.22         (drh      16-Sep-06):     }
1.22         (drh      16-Sep-06):   }
1.22         (drh      16-Sep-06): 
1.26         (drh      21-Sep-06):   iMatch = 0;
1.26         (drh      21-Sep-06):   for(i=0; i<nMatch && nDesired>0; i++){
1.26         (drh      21-Sep-06):     if( aMatch[i].snStatus!=SNIPPET_DESIRED ) continue;
1.26         (drh      21-Sep-06):     nDesired--;
1.26         (drh      21-Sep-06):     iCol = aMatch[i].iCol;
1.26         (drh      21-Sep-06):     zDoc = (const char*)sqlite3_column_text(pCursor->pStmt, iCol+1);
1.26         (drh      21-Sep-06):     nDoc = sqlite3_column_bytes(pCursor->pStmt, iCol+1);
1.26         (drh      21-Sep-06):     iStart = aMatch[i].iStart - 40;
1.26         (drh      21-Sep-06):     iStart = wordBoundary(iStart, zDoc, nDoc, aMatch, nMatch, iCol);
1.26         (drh      21-Sep-06):     if( iStart<=10 ){
1.26         (drh      21-Sep-06):       iStart = 0;
1.26         (drh      21-Sep-06):       wantEllipsis = 0;
1.26         (drh      21-Sep-06):     }else{
1.26         (drh      21-Sep-06):       wantEllipsis = 1;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     if( iCol==tailCol && iStart<=tailOffset+20 ){
1.26         (drh      21-Sep-06):       iStart = tailOffset;
1.26         (drh      21-Sep-06):       wantEllipsis = 0;
1.26         (drh      21-Sep-06):       tailEllipsis = 0;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     if( wantEllipsis || tailEllipsis ){
1.26         (drh      21-Sep-06):       append(&sb, zEllipsis);
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     iEnd = aMatch[i].iStart + aMatch[i].nByte + 40;
1.26         (drh      21-Sep-06):     iEnd = wordBoundary(iEnd, zDoc, nDoc, aMatch, nMatch, iCol);
1.26         (drh      21-Sep-06):     if( iEnd>=nDoc-10 ){
1.26         (drh      21-Sep-06):       iEnd = nDoc;
1.26         (drh      21-Sep-06):       tailEllipsis = 0;
1.26         (drh      21-Sep-06):     }else{
1.26         (drh      21-Sep-06):       tailEllipsis = 1;
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     while( iMatch<nMatch && aMatch[iMatch].iCol<iCol ){ iMatch++; }
1.26         (drh      21-Sep-06):     while( iStart<iEnd ){
1.26         (drh      21-Sep-06):       while( iMatch<nMatch && aMatch[iMatch].iStart<iStart ){ iMatch++; }
1.26         (drh      21-Sep-06):       if( iMatch<nMatch && aMatch[iMatch].iStart<iEnd ){
1.26         (drh      21-Sep-06):         nappend(&sb, &zDoc[iStart], aMatch[iMatch].iStart - iStart);
1.26         (drh      21-Sep-06):         iStart = aMatch[iMatch].iStart;
1.26         (drh      21-Sep-06):         append(&sb, zStartMark);
1.26         (drh      21-Sep-06):         nappend(&sb, &zDoc[iStart], aMatch[iMatch].nByte);
1.26         (drh      21-Sep-06):         append(&sb, zEndMark);
1.26         (drh      21-Sep-06):         iStart += aMatch[iMatch].nByte;
1.26         (drh      21-Sep-06):         for(j=iMatch+1; j<nMatch; j++){
1.26         (drh      21-Sep-06):           if( aMatch[j].iTerm==aMatch[iMatch].iTerm
1.26         (drh      21-Sep-06):               && aMatch[j].snStatus==SNIPPET_DESIRED ){
1.26         (drh      21-Sep-06):             nDesired--;
1.26         (drh      21-Sep-06):             aMatch[j].snStatus = SNIPPET_IGNORE;
1.26         (drh      21-Sep-06):           }
1.26         (drh      21-Sep-06):         }
1.26         (drh      21-Sep-06):       }else{
1.26         (drh      21-Sep-06):         nappend(&sb, &zDoc[iStart], iEnd - iStart);
1.26         (drh      21-Sep-06):         iStart = iEnd;
1.26         (drh      21-Sep-06):       }
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     tailCol = iCol;
1.26         (drh      21-Sep-06):     tailOffset = iEnd;
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   if( tailEllipsis ){
1.26         (drh      21-Sep-06):     append(&sb, zEllipsis);
1.26         (drh      21-Sep-06):   }
1.26         (drh      21-Sep-06):   pCursor->snippet.zSnippet = sb.s;
1.26         (drh      21-Sep-06):   pCursor->snippet.nSnippet = sb.len;  
1.22         (drh      16-Sep-06): }
1.22         (drh      16-Sep-06): 
1.22         (drh      16-Sep-06): 
1.22         (drh      16-Sep-06): /*
1.19         (drh      13-Sep-06): ** Close the cursor.  For additional information see the documentation
1.19         (drh      13-Sep-06): ** on the xClose method of the virtual table interface.
1.19         (drh      13-Sep-06): */
1.1          (drh      31-Aug-06): static int fulltextClose(sqlite3_vtab_cursor *pCursor){
1.1          (drh      31-Aug-06):   fulltext_cursor *c = (fulltext_cursor *) pCursor;
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Close %p\n", c));
1.1          (drh      31-Aug-06):   sqlite3_finalize(c->pStmt);
1.19         (drh      13-Sep-06):   queryClear(&c->q);
1.20         (drh      14-Sep-06):   snippetClear(&c->snippet);
1.1          (drh      31-Aug-06):   if( c->result.pDoclist!=NULL ){
1.1          (drh      31-Aug-06):     docListDelete(c->result.pDoclist);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   free(c);
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int fulltextNext(sqlite3_vtab_cursor *pCursor){
1.1          (drh      31-Aug-06):   fulltext_cursor *c = (fulltext_cursor *) pCursor;
1.1          (drh      31-Aug-06):   sqlite_int64 iDocid;
1.1          (drh      31-Aug-06):   int rc;
1.1          (drh      31-Aug-06): 
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Next %p\n", pCursor));
1.20         (drh      14-Sep-06):   snippetClear(&c->snippet);
1.14         (adamd    13-Sep-06):   if( c->iCursorType < QUERY_FULLTEXT ){
1.13         (adamd    12-Sep-06):     /* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */
1.13         (adamd    12-Sep-06):     rc = sqlite3_step(c->pStmt);
1.13         (adamd    12-Sep-06):     switch( rc ){
1.13         (adamd    12-Sep-06):       case SQLITE_ROW:
1.13         (adamd    12-Sep-06):         c->eof = 0;
1.13         (adamd    12-Sep-06):         return SQLITE_OK;
1.13         (adamd    12-Sep-06):       case SQLITE_DONE:
1.1          (drh      31-Aug-06):         c->eof = 1;
1.1          (drh      31-Aug-06):         return SQLITE_OK;
1.13         (adamd    12-Sep-06):       default:
1.13         (adamd    12-Sep-06):         c->eof = 1;
1.13         (adamd    12-Sep-06):         return rc;
1.13         (adamd    12-Sep-06):     }
1.13         (adamd    12-Sep-06):   } else {  /* full-text query */
1.13         (adamd    12-Sep-06):     rc = sqlite3_reset(c->pStmt);
1.13         (adamd    12-Sep-06):     if( rc!=SQLITE_OK ) return rc;
1.13         (adamd    12-Sep-06): 
1.13         (adamd    12-Sep-06):     iDocid = nextValidDocid(&c->result);
1.13         (adamd    12-Sep-06):     if( iDocid==0 ){
1.13         (adamd    12-Sep-06):       c->eof = 1;
1.13         (adamd    12-Sep-06):       return SQLITE_OK;
1.13         (adamd    12-Sep-06):     }
1.13         (adamd    12-Sep-06):     rc = sqlite3_bind_int64(c->pStmt, 1, iDocid);
1.13         (adamd    12-Sep-06):     if( rc!=SQLITE_OK ) return rc;
1.13         (adamd    12-Sep-06):     /* TODO(shess) Handle SQLITE_SCHEMA AND SQLITE_BUSY. */
1.13         (adamd    12-Sep-06):     rc = sqlite3_step(c->pStmt);
1.13         (adamd    12-Sep-06):     if( rc==SQLITE_ROW ){   /* the case we expect */
1.13         (adamd    12-Sep-06):       c->eof = 0;
1.13         (adamd    12-Sep-06):       return SQLITE_OK;
1.13         (adamd    12-Sep-06):     }
1.13         (adamd    12-Sep-06):     /* an error occurred; abort */
1.13         (adamd    12-Sep-06):     return rc==SQLITE_DONE ? SQLITE_ERROR : rc;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06): /* Return a DocList corresponding to the query term *pTerm.  If *pTerm
1.9          (drh      10-Sep-06): ** is the first term of a phrase query, go ahead and evaluate the phrase
1.9          (drh      10-Sep-06): ** query and return the doclist for the entire phrase query.
1.9          (drh      10-Sep-06): **
1.9          (drh      10-Sep-06): ** The result is stored in pTerm->doclist.
1.9          (drh      10-Sep-06): */
1.9          (drh      10-Sep-06): static int docListOfTerm(
1.9          (drh      10-Sep-06):   fulltext_vtab *v,     /* The full text index */
1.15         (drh      13-Sep-06):   int iColumn,          /* column to restrict to.  No restrition if >=nColumn */
1.9          (drh      10-Sep-06):   QueryTerm *pQTerm,    /* Term we are looking for, or 1st term of a phrase */
1.9          (drh      10-Sep-06):   DocList **ppResult    /* Write the result here */
1.9          (drh      10-Sep-06): ){
1.9          (drh      10-Sep-06):   DocList *pLeft, *pRight, *pNew;
1.9          (drh      10-Sep-06):   int i, rc;
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06):   pLeft = docListNew(DL_POSITIONS);
1.14         (adamd    13-Sep-06):   rc = term_select_all(v, iColumn, pQTerm->pTerm, pQTerm->nTerm, pLeft);
1.9          (drh      10-Sep-06):   if( rc ) return rc;
1.9          (drh      10-Sep-06):   for(i=1; i<=pQTerm->nPhrase; i++){
1.9          (drh      10-Sep-06):     pRight = docListNew(DL_POSITIONS);
1.14         (adamd    13-Sep-06):     rc = term_select_all(v, iColumn, pQTerm[i].pTerm, pQTerm[i].nTerm, pRight);
1.9          (drh      10-Sep-06):     if( rc ){
1.9          (drh      10-Sep-06):       docListDelete(pLeft);
1.9          (drh      10-Sep-06):       return rc;
1.9          (drh      10-Sep-06):     }
1.9          (drh      10-Sep-06):     pNew = docListNew(i<pQTerm->nPhrase ? DL_POSITIONS : DL_DOCIDS);
1.9          (drh      10-Sep-06):     docListPhraseMerge(pLeft, pRight, pNew);
1.9          (drh      10-Sep-06):     docListDelete(pLeft);
1.9          (drh      10-Sep-06):     docListDelete(pRight);
1.9          (drh      10-Sep-06):     pLeft = pNew;
1.9          (drh      10-Sep-06):   }
1.9          (drh      10-Sep-06):   *ppResult = pLeft;
1.9          (drh      10-Sep-06):   return SQLITE_OK;
1.9          (drh      10-Sep-06): }
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06): /* Add a new term pTerm[0..nTerm-1] to the query *q.
1.8          (drh      09-Sep-06): */
1.9          (drh      10-Sep-06): static void queryAdd(Query *q, const char *pTerm, int nTerm){
1.1          (drh      31-Aug-06):   QueryTerm *t;
1.1          (drh      31-Aug-06):   ++q->nTerms;
1.3          (adamd    02-Sep-06):   q->pTerms = realloc(q->pTerms, q->nTerms * sizeof(q->pTerms[0]));
1.8          (drh      09-Sep-06):   if( q->pTerms==0 ){
1.8          (drh      09-Sep-06):     q->nTerms = 0;
1.8          (drh      09-Sep-06):     return;
1.8          (drh      09-Sep-06):   }
1.3          (adamd    02-Sep-06):   t = &q->pTerms[q->nTerms - 1];
1.8          (drh      09-Sep-06):   memset(t, 0, sizeof(*t));
1.8          (drh      09-Sep-06):   t->pTerm = malloc(nTerm+1);
1.2          (shess    01-Sep-06):   memcpy(t->pTerm, pTerm, nTerm);
1.8          (drh      09-Sep-06):   t->pTerm[nTerm] = 0;
1.2          (shess    01-Sep-06):   t->nTerm = nTerm;
1.9          (drh      10-Sep-06):   t->isOr = q->nextIsOr;
1.9          (drh      10-Sep-06):   q->nextIsOr = 0;
1.18         (drh      13-Sep-06):   t->iColumn = q->nextColumn;
1.18         (drh      13-Sep-06):   q->nextColumn = q->dfltColumn;
1.1          (drh      31-Aug-06): }
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06): /*
1.17         (drh      13-Sep-06): ** Check to see if the string zToken[0...nToken-1] matches any
1.17         (drh      13-Sep-06): ** column name in the virtual table.   If it does,
1.17         (drh      13-Sep-06): ** return the zero-indexed column number.  If not, return -1.
1.17         (drh      13-Sep-06): */
1.17         (drh      13-Sep-06): static int checkColumnSpecifier(
1.17         (drh      13-Sep-06):   fulltext_vtab *pVtab,    /* The virtual table */
1.17         (drh      13-Sep-06):   const char *zToken,      /* Text of the token */
1.17         (drh      13-Sep-06):   int nToken               /* Number of characters in the token */
1.17         (drh      13-Sep-06): ){
1.17         (drh      13-Sep-06):   int i;
1.17         (drh      13-Sep-06):   for(i=0; i<pVtab->nColumn; i++){
1.17         (drh      13-Sep-06):     if( memcmp(pVtab->azColumn[i], zToken, nToken)==0
1.17         (drh      13-Sep-06):         && pVtab->azColumn[i][nToken]==0 ){
1.17         (drh      13-Sep-06):       return i;
1.17         (drh      13-Sep-06):     }
1.17         (drh      13-Sep-06):   }
1.17         (drh      13-Sep-06):   return -1;
1.17         (drh      13-Sep-06): }
1.17         (drh      13-Sep-06): 
1.17         (drh      13-Sep-06): /*
1.8          (drh      09-Sep-06): ** Parse the text at pSegment[0..nSegment-1].  Add additional terms
1.8          (drh      09-Sep-06): ** to the query being assemblied in pQuery.
1.8          (drh      09-Sep-06): **
1.8          (drh      09-Sep-06): ** inPhrase is true if pSegment[0..nSegement-1] is contained within
1.9          (drh      10-Sep-06): ** double-quotes.  If inPhrase is true, then the first term
1.9          (drh      10-Sep-06): ** is marked with the number of terms in the phrase less one and
1.9          (drh      10-Sep-06): ** OR and "-" syntax is ignored.  If inPhrase is false, then every
1.9          (drh      10-Sep-06): ** term found is marked with nPhrase=0 and OR and "-" syntax is significant.
1.9          (drh      10-Sep-06): */
1.9          (drh      10-Sep-06): static int tokenizeSegment(
1.9          (drh      10-Sep-06):   sqlite3_tokenizer *pTokenizer,          /* The tokenizer to use */
1.9          (drh      10-Sep-06):   const char *pSegment, int nSegment,     /* Query expression being parsed */
1.9          (drh      10-Sep-06):   int inPhrase,                           /* True if within "..." */
1.9          (drh      10-Sep-06):   Query *pQuery                           /* Append results here */
1.9          (drh      10-Sep-06): ){
1.4          (drh      02-Sep-06):   const sqlite3_tokenizer_module *pModule = pTokenizer->pModule;
1.1          (drh      31-Aug-06):   sqlite3_tokenizer_cursor *pCursor;
1.9          (drh      10-Sep-06):   int firstIndex = pQuery->nTerms;
1.17         (drh      13-Sep-06):   int iCol;
1.20         (drh      14-Sep-06):   int nTerm = 1;
1.1          (drh      31-Aug-06):   
1.2          (shess    01-Sep-06):   int rc = pModule->xOpen(pTokenizer, pSegment, nSegment, &pCursor);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06):   pCursor->pTokenizer = pTokenizer;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   while( 1 ){
1.2          (shess    01-Sep-06):     const char *pToken;
1.8          (drh      09-Sep-06):     int nToken, iBegin, iEnd, iPos;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     rc = pModule->xNext(pCursor,
1.2          (shess    01-Sep-06):                         &pToken, &nToken,
1.8          (drh      09-Sep-06):                         &iBegin, &iEnd, &iPos);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) break;
1.17         (drh      13-Sep-06):     if( !inPhrase &&
1.17         (drh      13-Sep-06):         pSegment[iEnd]==':' &&
1.17         (drh      13-Sep-06):          (iCol = checkColumnSpecifier(pQuery->pFts, pToken, nToken))>=0 ){
1.18         (drh      13-Sep-06):       pQuery->nextColumn = iCol;
1.17         (drh      13-Sep-06):       continue;
1.17         (drh      13-Sep-06):     }
1.8          (drh      09-Sep-06):     if( !inPhrase && pQuery->nTerms>0 && nToken==2
1.8          (drh      09-Sep-06):          && pSegment[iBegin]=='O' && pSegment[iBegin+1]=='R' ){
1.9          (drh      10-Sep-06):       pQuery->nextIsOr = 1;
1.8          (drh      09-Sep-06):       continue;
1.8          (drh      09-Sep-06):     }
1.9          (drh      10-Sep-06):     queryAdd(pQuery, pToken, nToken);
1.9          (drh      10-Sep-06):     if( !inPhrase && iBegin>0 && pSegment[iBegin-1]=='-' ){
1.9          (drh      10-Sep-06):       pQuery->pTerms[pQuery->nTerms-1].isNot = 1;
1.8          (drh      09-Sep-06):     }
1.20         (drh      14-Sep-06):     pQuery->pTerms[pQuery->nTerms-1].iPhrase = nTerm;
1.20         (drh      14-Sep-06):     if( inPhrase ){
1.20         (drh      14-Sep-06):       nTerm++;
1.20         (drh      14-Sep-06):     }
1.9          (drh      10-Sep-06):   }
1.9          (drh      10-Sep-06): 
1.9          (drh      10-Sep-06):   if( inPhrase && pQuery->nTerms>firstIndex ){
1.9          (drh      10-Sep-06):     pQuery->pTerms[firstIndex].nPhrase = pQuery->nTerms - firstIndex - 1;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   return pModule->xClose(pCursor);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.18         (drh      13-Sep-06): /* Parse a query string, yielding a Query object pQuery.
1.18         (drh      13-Sep-06): **
1.18         (drh      13-Sep-06): ** The calling function will need to queryClear() to clean up
1.18         (drh      13-Sep-06): ** the dynamically allocated memory held by pQuery.
1.18         (drh      13-Sep-06): */
1.18         (drh      13-Sep-06): static int parseQuery(
1.18         (drh      13-Sep-06):   fulltext_vtab *v,        /* The fulltext index */
1.18         (drh      13-Sep-06):   const char *zInput,      /* Input text of the query string */
1.18         (drh      13-Sep-06):   int nInput,              /* Size of the input text */
1.18         (drh      13-Sep-06):   int dfltColumn,          /* Default column of the index to match against */
1.18         (drh      13-Sep-06):   Query *pQuery            /* Write the parse results here. */
1.18         (drh      13-Sep-06): ){
1.3          (adamd    02-Sep-06):   int iInput, inPhrase = 0;
1.2          (shess    01-Sep-06): 
1.18         (drh      13-Sep-06):   if( nInput<0 ) nInput = strlen(zInput);
1.1          (drh      31-Aug-06):   pQuery->nTerms = 0;
1.3          (adamd    02-Sep-06):   pQuery->pTerms = NULL;
1.9          (drh      10-Sep-06):   pQuery->nextIsOr = 0;
1.18         (drh      13-Sep-06):   pQuery->nextColumn = dfltColumn;
1.18         (drh      13-Sep-06):   pQuery->dfltColumn = dfltColumn;
1.17         (drh      13-Sep-06):   pQuery->pFts = v;
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06):   for(iInput=0; iInput<nInput; ++iInput){
1.2          (shess    01-Sep-06):     int i;
1.18         (drh      13-Sep-06):     for(i=iInput; i<nInput && zInput[i]!='"'; ++i){}
1.2          (shess    01-Sep-06):     if( i>iInput ){
1.18         (drh      13-Sep-06):       tokenizeSegment(v->pTokenizer, zInput+iInput, i-iInput, inPhrase,
1.2          (shess    01-Sep-06):                        pQuery);
1.1          (drh      31-Aug-06):     }
1.2          (shess    01-Sep-06):     iInput = i;
1.3          (adamd    02-Sep-06):     if( i<nInput ){
1.18         (drh      13-Sep-06):       assert( zInput[i]=='"' );
1.3          (adamd    02-Sep-06):       inPhrase = !inPhrase;
1.3          (adamd    02-Sep-06):     }
1.3          (adamd    02-Sep-06):   }
1.3          (adamd    02-Sep-06): 
1.18         (drh      13-Sep-06):   if( inPhrase ){
1.18         (drh      13-Sep-06):     /* unmatched quote */
1.18         (drh      13-Sep-06):     queryClear(pQuery);
1.3          (adamd    02-Sep-06):     return SQLITE_ERROR;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06): /* Perform a full-text query using the search expression in
1.18         (drh      13-Sep-06): ** zInput[0..nInput-1].  Return a list of matching documents
1.8          (drh      09-Sep-06): ** in pResult.
1.17         (drh      13-Sep-06): **
1.17         (drh      13-Sep-06): ** Queries must match column iColumn.  Or if iColumn>=nColumn
1.17         (drh      13-Sep-06): ** they are allowed to match against any column.
1.8          (drh      09-Sep-06): */
1.18         (drh      13-Sep-06): static int fulltextQuery(
1.18         (drh      13-Sep-06):   fulltext_vtab *v,      /* The full text index */
1.18         (drh      13-Sep-06):   int iColumn,           /* Match against this column by default */
1.18         (drh      13-Sep-06):   const char *zInput,    /* The query string */
1.18         (drh      13-Sep-06):   int nInput,            /* Number of bytes in zInput[] */
1.19         (drh      13-Sep-06):   DocList **pResult,     /* Write the result doclist here */
1.19         (drh      13-Sep-06):   Query *pQuery          /* Put parsed query string here */
1.18         (drh      13-Sep-06): ){
1.9          (drh      10-Sep-06):   int i, rc;
1.9          (drh      10-Sep-06):   DocList *pLeft = NULL;
1.9          (drh      10-Sep-06):   DocList *pRight, *pNew;
1.9          (drh      10-Sep-06):   int nNot = 0;
1.19         (drh      13-Sep-06):   QueryTerm *aTerm;
1.1          (drh      31-Aug-06): 
1.19         (drh      13-Sep-06):   rc = parseQuery(v, zInput, nInput, iColumn, pQuery);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.8          (drh      09-Sep-06):   /* Merge AND terms. */
1.19         (drh      13-Sep-06):   aTerm = pQuery->pTerms;
1.19         (drh      13-Sep-06):   for(i = 0; i<pQuery->nTerms; i += aTerm[i].nPhrase + 1){
1.8          (drh      09-Sep-06): 
1.19         (drh      13-Sep-06):     if( aTerm[i].isNot ){
1.9          (drh      10-Sep-06):       /* Handle all NOT terms in a separate pass */
1.9          (drh      10-Sep-06):       nNot++;
1.8          (drh      09-Sep-06):       continue;
1.8          (drh      09-Sep-06):     }
1.8          (drh      09-Sep-06): 
1.19         (drh      13-Sep-06):     rc = docListOfTerm(v, aTerm[i].iColumn, &aTerm[i], &pRight);
1.9          (drh      10-Sep-06):     if( rc ){
1.19         (drh      13-Sep-06):       queryClear(pQuery);
1.9          (drh      10-Sep-06):       return rc;
1.1          (drh      31-Aug-06):     }
1.9          (drh      10-Sep-06):     if( pLeft==0 ){
1.9          (drh      10-Sep-06):       pLeft = pRight;
1.9          (drh      10-Sep-06):     }else{
1.9          (drh      10-Sep-06):       pNew = docListNew(DL_DOCIDS);
1.19         (drh      13-Sep-06):       if( aTerm[i].isOr ){
1.9          (drh      10-Sep-06):         docListOrMerge(pLeft, pRight, pNew);
1.9          (drh      10-Sep-06):       }else{
1.9          (drh      10-Sep-06):         docListAndMerge(pLeft, pRight, pNew);
1.9          (drh      10-Sep-06):       }
1.9          (drh      10-Sep-06):       docListDelete(pRight);
1.9          (drh      10-Sep-06):       docListDelete(pLeft);
1.9          (drh      10-Sep-06):       pLeft = pNew;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.9          (drh      10-Sep-06):   if( nNot && pLeft==0 ){
1.9          (drh      10-Sep-06):     /* We do not yet know how to handle a query of only NOT terms */
1.9          (drh      10-Sep-06):     return SQLITE_ERROR;
1.8          (drh      09-Sep-06):   }
1.8          (drh      09-Sep-06): 
1.8          (drh      09-Sep-06):   /* Do the EXCEPT terms */
1.19         (drh      13-Sep-06):   for(i=0; i<pQuery->nTerms;  i += aTerm[i].nPhrase + 1){
1.19         (drh      13-Sep-06):     if( !aTerm[i].isNot ) continue;
1.19         (drh      13-Sep-06):     rc = docListOfTerm(v, aTerm[i].iColumn, &aTerm[i], &pRight);
1.9          (drh      10-Sep-06):     if( rc ){
1.19         (drh      13-Sep-06):       queryClear(pQuery);
1.9          (drh      10-Sep-06):       docListDelete(pLeft);
1.9          (drh      10-Sep-06):       return rc;
1.9          (drh      10-Sep-06):     }
1.9          (drh      10-Sep-06):     pNew = docListNew(DL_DOCIDS);
1.9          (drh      10-Sep-06):     docListExceptMerge(pLeft, pRight, pNew);
1.9          (drh      10-Sep-06):     docListDelete(pRight);
1.9          (drh      10-Sep-06):     docListDelete(pLeft);
1.9          (drh      10-Sep-06):     pLeft = pNew;
1.8          (drh      09-Sep-06):   }
1.8          (drh      09-Sep-06): 
1.9          (drh      10-Sep-06):   *pResult = pLeft;
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.15         (drh      13-Sep-06): /*
1.15         (drh      13-Sep-06): ** This is the xFilter interface for the virtual table.  See
1.15         (drh      13-Sep-06): ** the virtual table xFilter method documentation for additional
1.15         (drh      13-Sep-06): ** information.
1.15         (drh      13-Sep-06): **
1.15         (drh      13-Sep-06): ** If idxNum==QUERY_GENERIC then do a full table scan against
1.15         (drh      13-Sep-06): ** the %_content table.
1.15         (drh      13-Sep-06): **
1.15         (drh      13-Sep-06): ** If idxNum==QUERY_ROWID then do a rowid lookup for a single entry
1.15         (drh      13-Sep-06): ** in the %_content table.
1.15         (drh      13-Sep-06): **
1.15         (drh      13-Sep-06): ** If idxNum>=QUERY_FULLTEXT then use the full text index.  The
1.15         (drh      13-Sep-06): ** column on the left-hand side of the MATCH operator is column
1.15         (drh      13-Sep-06): ** number idxNum-QUERY_FULLTEXT, 0 indexed.  argv[0] is the right-hand
1.15         (drh      13-Sep-06): ** side of the MATCH operator.
1.15         (drh      13-Sep-06): */
1.15         (drh      13-Sep-06): static int fulltextFilter(
1.15         (drh      13-Sep-06):   sqlite3_vtab_cursor *pCursor,     /* The cursor used for this query */
1.15         (drh      13-Sep-06):   int idxNum, const char *idxStr,   /* Which indexing scheme to use */
1.15         (drh      13-Sep-06):   int argc, sqlite3_value **argv    /* Arguments for the indexing scheme */
1.15         (drh      13-Sep-06): ){
1.1          (drh      31-Aug-06):   fulltext_cursor *c = (fulltext_cursor *) pCursor;
1.1          (drh      31-Aug-06):   fulltext_vtab *v = cursor_vtab(c);
1.1          (drh      31-Aug-06):   int rc;
1.16         (drh      13-Sep-06):   char *zSql;
1.1          (drh      31-Aug-06): 
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Filter %p\n",pCursor));
1.14         (adamd    13-Sep-06): 
1.16         (drh      13-Sep-06):   zSql = sqlite3_mprintf("select rowid, * from %%_content %s",
1.16         (drh      13-Sep-06):                           idxNum==QUERY_GENERIC ? "" : "where rowid=?");
1.16         (drh      13-Sep-06):   rc = sql_prepare(v->db, v->zName, &c->pStmt, zSql);
1.16         (drh      13-Sep-06):   sqlite3_free(zSql);
1.14         (adamd    13-Sep-06):   if( rc!=SQLITE_OK ) goto out;
1.14         (adamd    13-Sep-06): 
1.1          (drh      31-Aug-06):   c->iCursorType = idxNum;
1.1          (drh      31-Aug-06):   switch( idxNum ){
1.1          (drh      31-Aug-06):     case QUERY_GENERIC:
1.13         (adamd    12-Sep-06):       break;
1.13         (adamd    12-Sep-06): 
1.13         (adamd    12-Sep-06):     case QUERY_ROWID:
1.13         (adamd    12-Sep-06):       rc = sqlite3_bind_int64(c->pStmt, 1, sqlite3_value_int64(argv[0]));
1.14         (adamd    13-Sep-06):       if( rc!=SQLITE_OK ) goto out;
1.1          (drh      31-Aug-06):       break;
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):     default:   /* full-text search */
1.1          (drh      31-Aug-06):     {
1.1          (drh      31-Aug-06):       const char *zQuery = (const char *)sqlite3_value_text(argv[0]);
1.1          (drh      31-Aug-06):       DocList *pResult;
1.16         (drh      13-Sep-06):       assert( idxNum<=QUERY_FULLTEXT+v->nColumn);
1.1          (drh      31-Aug-06):       assert( argc==1 );
1.19         (drh      13-Sep-06):       queryClear(&c->q);
1.19         (drh      13-Sep-06):       rc = fulltextQuery(v, idxNum-QUERY_FULLTEXT, zQuery, -1, &pResult, &c->q);
1.14         (adamd    13-Sep-06):       if( rc!=SQLITE_OK ) goto out;
1.1          (drh      31-Aug-06):       readerInit(&c->result, pResult);
1.1          (drh      31-Aug-06):       break;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):   rc = fulltextNext(pCursor);
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): out:
1.14         (adamd    13-Sep-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.20         (drh      14-Sep-06): /* This is the xEof method of the virtual table.  The SQLite core
1.20         (drh      14-Sep-06): ** calls this routine to find out if it has reached the end of
1.20         (drh      14-Sep-06): ** a query's results set.
1.20         (drh      14-Sep-06): */
1.1          (drh      31-Aug-06): static int fulltextEof(sqlite3_vtab_cursor *pCursor){
1.1          (drh      31-Aug-06):   fulltext_cursor *c = (fulltext_cursor *) pCursor;
1.1          (drh      31-Aug-06):   return c->eof;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.20         (drh      14-Sep-06): /* This is the xColumn method of the virtual table.  The SQLite
1.20         (drh      14-Sep-06): ** core calls this method during a query when it needs the value
1.20         (drh      14-Sep-06): ** of a column from the virtual table.  This method needs to use
1.20         (drh      14-Sep-06): ** one of the sqlite3_result_*() routines to store the requested
1.20         (drh      14-Sep-06): ** value back in the pContext.
1.20         (drh      14-Sep-06): */
1.1          (drh      31-Aug-06): static int fulltextColumn(sqlite3_vtab_cursor *pCursor,
1.1          (drh      31-Aug-06):                           sqlite3_context *pContext, int idxCol){
1.1          (drh      31-Aug-06):   fulltext_cursor *c = (fulltext_cursor *) pCursor;
1.14         (adamd    13-Sep-06):   fulltext_vtab *v = cursor_vtab(c);
1.1          (drh      31-Aug-06): 
1.20         (drh      14-Sep-06):   if( idxCol<v->nColumn ){
1.20         (drh      14-Sep-06):     sqlite3_value *pVal = sqlite3_column_value(c->pStmt, idxCol+1);
1.20         (drh      14-Sep-06):     sqlite3_result_value(pContext, pVal);
1.20         (drh      14-Sep-06):   }else if( idxCol==v->nColumn ){
1.23         (drh      18-Sep-06):     /* The extra column whose name is the same as the table.
1.23         (drh      18-Sep-06):     ** Return a blob which is a pointer to the cursor
1.23         (drh      18-Sep-06):     */
1.23         (drh      18-Sep-06):     sqlite3_result_blob(pContext, &c, sizeof(c), SQLITE_TRANSIENT);
1.14         (adamd    13-Sep-06):   }
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.20         (drh      14-Sep-06): /* This is the xRowid method.  The SQLite core calls this routine to
1.20         (drh      14-Sep-06): ** retrive the rowid for the current row of the result set.  The
1.20         (drh      14-Sep-06): ** rowid should be written to *pRowid.
1.20         (drh      14-Sep-06): */
1.1          (drh      31-Aug-06): static int fulltextRowid(sqlite3_vtab_cursor *pCursor, sqlite_int64 *pRowid){
1.1          (drh      31-Aug-06):   fulltext_cursor *c = (fulltext_cursor *) pCursor;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   *pRowid = sqlite3_column_int64(c->pStmt, 0);
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): /* Add all terms/positions in [zText] to the given hash table. */
1.14         (adamd    13-Sep-06): static int buildTerms(fulltext_vtab *v, fts1Hash *terms, int iColumn,
1.14         (adamd    13-Sep-06):                       const char *zText, int nText, sqlite_int64 iDocid){
1.14         (adamd    13-Sep-06):   sqlite3_tokenizer *pTokenizer = v->pTokenizer;
1.1          (drh      31-Aug-06):   sqlite3_tokenizer_cursor *pCursor;
1.1          (drh      31-Aug-06):   const char *pToken;
1.1          (drh      31-Aug-06):   int nTokenBytes;
1.1          (drh      31-Aug-06):   int iStartOffset, iEndOffset, iPosition;
1.2          (shess    01-Sep-06):   int rc;
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):   rc = pTokenizer->pModule->xOpen(pTokenizer, zText, nText, &pCursor);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   pCursor->pTokenizer = pTokenizer;
1.1          (drh      31-Aug-06):   while( SQLITE_OK==pTokenizer->pModule->xNext(pCursor,
1.1          (drh      31-Aug-06):                                                &pToken, &nTokenBytes,
1.1          (drh      31-Aug-06):                                                &iStartOffset, &iEndOffset,
1.1          (drh      31-Aug-06):                                                &iPosition) ){
1.1          (drh      31-Aug-06):     DocList *p;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     /* Positions can't be negative; we use -1 as a terminator internally. */
1.14         (adamd    13-Sep-06):     if( iPosition<0 ){
1.14         (adamd    13-Sep-06):       pTokenizer->pModule->xClose(pCursor);
1.14         (adamd    13-Sep-06):       return SQLITE_ERROR;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):     p = fts1HashFind(terms, pToken, nTokenBytes);
1.1          (drh      31-Aug-06):     if( p==NULL ){
1.1          (drh      31-Aug-06):       p = docListNew(DL_POSITIONS_OFFSETS);
1.1          (drh      31-Aug-06):       docListAddDocid(p, iDocid);
1.1          (drh      31-Aug-06):       fts1HashInsert(terms, pToken, nTokenBytes, p);
1.1          (drh      31-Aug-06):     }
1.14         (adamd    13-Sep-06):     docListAddPosOffset(p, iColumn, iPosition, iStartOffset, iEndOffset);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /* TODO(shess) Check return?  Should this be able to cause errors at
1.1          (drh      31-Aug-06):   ** this point?  Actually, same question about sqlite3_finalize(),
1.1          (drh      31-Aug-06):   ** though one could argue that failure there means that the data is
1.1          (drh      31-Aug-06):   ** not durable.  *ponder*
1.1          (drh      31-Aug-06):   */
1.1          (drh      31-Aug-06):   pTokenizer->pModule->xClose(pCursor);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06): /* Update the %_terms table to map the term [pTerm] to the given rowid. */
1.2          (shess    01-Sep-06): static int index_insert_term(fulltext_vtab *v, const char *pTerm, int nTerm,
1.7          (shess    08-Sep-06):                              DocList *d){
1.1          (drh      31-Aug-06):   sqlite_int64 iIndexRow;
1.1          (drh      31-Aug-06):   DocList doclist;
1.7          (shess    08-Sep-06):   int iSegment = 0, rc;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   rc = term_select(v, pTerm, nTerm, iSegment, &iIndexRow, &doclist);
1.1          (drh      31-Aug-06):   if( rc==SQLITE_DONE ){
1.1          (drh      31-Aug-06):     docListInit(&doclist, DL_POSITIONS_OFFSETS, 0, 0);
1.7          (shess    08-Sep-06):     docListUpdate(&doclist, d);
1.7          (shess    08-Sep-06):     /* TODO(shess) Consider length(doclist)>CHUNK_MAX? */
1.12         (shess    11-Sep-06):     rc = term_insert(v, NULL, pTerm, nTerm, iSegment, &doclist);
1.7          (shess    08-Sep-06):     goto err;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_ROW ) return SQLITE_ERROR;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   docListUpdate(&doclist, d);
1.7          (shess    08-Sep-06):   if( doclist.nData<=CHUNK_MAX ){
1.7          (shess    08-Sep-06):     rc = term_update(v, iIndexRow, &doclist);
1.7          (shess    08-Sep-06):     goto err;
1.7          (shess    08-Sep-06):   }
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):   /* Doclist doesn't fit, delete what's there, and accumulate
1.7          (shess    08-Sep-06):   ** forward.
1.7          (shess    08-Sep-06):   */
1.7          (shess    08-Sep-06):   rc = term_delete(v, iIndexRow);
1.7          (shess    08-Sep-06):   if( rc!=SQLITE_OK ) goto err;
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):   /* Try to insert the doclist into a higher segment bucket.  On
1.7          (shess    08-Sep-06):   ** failure, accumulate existing doclist with the doclist from that
1.7          (shess    08-Sep-06):   ** bucket, and put results in the next bucket.
1.7          (shess    08-Sep-06):   */
1.7          (shess    08-Sep-06):   iSegment++;
1.12         (shess    11-Sep-06):   while( (rc=term_insert(v, &iIndexRow, pTerm, nTerm, iSegment,
1.12         (shess    11-Sep-06):                          &doclist))!=SQLITE_OK ){
1.12         (shess    11-Sep-06):     sqlite_int64 iSegmentRow;
1.7          (shess    08-Sep-06):     DocList old;
1.7          (shess    08-Sep-06):     int rc2;
1.7          (shess    08-Sep-06): 
1.7          (shess    08-Sep-06):     /* Retain old error in case the term_insert() error was really an
1.7          (shess    08-Sep-06):     ** error rather than a bounced insert.
1.7          (shess    08-Sep-06):     */
1.12         (shess    11-Sep-06):     rc2 = term_select(v, pTerm, nTerm, iSegment, &iSegmentRow, &old);
1.7          (shess    08-Sep-06):     if( rc2!=SQLITE_ROW ) goto err;
1.7          (shess    08-Sep-06): 
1.12         (shess    11-Sep-06):     rc = term_delete(v, iSegmentRow);
1.7          (shess    08-Sep-06):     if( rc!=SQLITE_OK ) goto err;
1.1          (drh      31-Aug-06): 
1.12         (shess    11-Sep-06):     /* Reusing lowest-number deleted row keeps the index smaller. */
1.12         (shess    11-Sep-06):     if( iSegmentRow<iIndexRow ) iIndexRow = iSegmentRow;
1.12         (shess    11-Sep-06): 
1.7          (shess    08-Sep-06):     /* doclist contains the newer data, so accumulate it over old.
1.7          (shess    08-Sep-06):     ** Then steal accumulated data for doclist.
1.7          (shess    08-Sep-06):     */
1.7          (shess    08-Sep-06):     docListAccumulate(&old, &doclist);
1.7          (shess    08-Sep-06):     docListDestroy(&doclist);
1.7          (shess    08-Sep-06):     doclist = old;
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):     iSegment++;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):  err:
1.1          (drh      31-Aug-06):   docListDestroy(&doclist);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Insert a row into the full-text index; set *piRowid to be the ID of the
1.1          (drh      31-Aug-06):  * new row. */
1.2          (shess    01-Sep-06): static int index_insert(fulltext_vtab *v, sqlite3_value *pRequestRowid,
1.14         (adamd    13-Sep-06):                         sqlite3_value **pValues,
1.1          (drh      31-Aug-06):                         sqlite_int64 *piRowid){
1.14         (adamd    13-Sep-06):   int i;
1.1          (drh      31-Aug-06):   fts1Hash terms;  /* maps term string -> PosList */
1.1          (drh      31-Aug-06):   fts1HashElem *e;
1.2          (shess    01-Sep-06):   int rc;
1.2          (shess    01-Sep-06): 
1.14         (adamd    13-Sep-06):   rc = content_insert(v, pRequestRowid, pValues);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06):   *piRowid = sqlite3_last_insert_rowid(v->db);
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):   fts1HashInit(&terms, FTS1_HASH_STRING, 1);
1.16         (drh      13-Sep-06):   for(i = 0; i < v->nColumn ; ++i){
1.16         (drh      13-Sep-06):     rc = buildTerms(v, &terms, i, (char*)sqlite3_value_text(pValues[i]), -1,
1.16         (drh      13-Sep-06):                     *piRowid);
1.14         (adamd    13-Sep-06):     if( rc!=SQLITE_OK ) goto out;
1.14         (adamd    13-Sep-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   for(e=fts1HashFirst(&terms); e; e=fts1HashNext(e)){
1.1          (drh      31-Aug-06):     DocList *p = fts1HashData(e);
1.7          (shess    08-Sep-06):     rc = index_insert_term(v, fts1HashKey(e), fts1HashKeysize(e), p);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) break;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06): out:
1.1          (drh      31-Aug-06):   for(e=fts1HashFirst(&terms); e; e=fts1HashNext(e)){
1.1          (drh      31-Aug-06):     DocList *p = fts1HashData(e);
1.1          (drh      31-Aug-06):     docListDelete(p);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   fts1HashClear(&terms);
1.1          (drh      31-Aug-06):   return rc;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Delete a row from the full-text index. */
1.1          (drh      31-Aug-06): static int index_delete(fulltext_vtab *v, sqlite_int64 iRow){
1.14         (adamd    13-Sep-06):   const char **pValues;
1.1          (drh      31-Aug-06):   fts1Hash terms;
1.14         (adamd    13-Sep-06):   int i;
1.1          (drh      31-Aug-06):   fts1HashElem *e;
1.7          (shess    08-Sep-06):   DocList doclist;
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):   int rc = content_select(v, iRow, &pValues);
1.1          (drh      31-Aug-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):   fts1HashInit(&terms, FTS1_HASH_STRING, 1);
1.16         (drh      13-Sep-06):   for(i = 0 ; i < v->nColumn; ++i) {
1.14         (adamd    13-Sep-06):     rc = buildTerms(v, &terms, i, pValues[i], -1, iRow);
1.14         (adamd    13-Sep-06):     if( rc!=SQLITE_OK ) goto out;
1.14         (adamd    13-Sep-06):   }
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   /* Delete by inserting a doclist with no positions.  This will
1.7          (shess    08-Sep-06):   ** overwrite existing data as it is merged forward by
1.7          (shess    08-Sep-06):   ** index_insert_term().
1.7          (shess    08-Sep-06):   */
1.7          (shess    08-Sep-06):   docListInit(&doclist, DL_POSITIONS_OFFSETS, 0, 0);
1.7          (shess    08-Sep-06):   docListAddDocid(&doclist, iRow);
1.7          (shess    08-Sep-06): 
1.1          (drh      31-Aug-06):   for(e=fts1HashFirst(&terms); e; e=fts1HashNext(e)){
1.7          (shess    08-Sep-06):     rc = index_insert_term(v, fts1HashKey(e), fts1HashKeysize(e), &doclist);
1.1          (drh      31-Aug-06):     if( rc!=SQLITE_OK ) break;
1.1          (drh      31-Aug-06):   }
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06): out:
1.16         (drh      13-Sep-06):   freeStringArray(v->nColumn, pValues);
1.1          (drh      31-Aug-06):   for(e=fts1HashFirst(&terms); e; e=fts1HashNext(e)){
1.1          (drh      31-Aug-06):     DocList *p = fts1HashData(e);
1.1          (drh      31-Aug-06):     docListDelete(p);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   fts1HashClear(&terms);
1.7          (shess    08-Sep-06):   docListDestroy(&doclist);
1.1          (drh      31-Aug-06): 
1.7          (shess    08-Sep-06):   if( rc!=SQLITE_OK ) return rc;
1.1          (drh      31-Aug-06):   return content_delete(v, iRow);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int fulltextUpdate(sqlite3_vtab *pVtab, int nArg, sqlite3_value **ppArg,
1.1          (drh      31-Aug-06):                    sqlite_int64 *pRowid){
1.1          (drh      31-Aug-06):   fulltext_vtab *v = (fulltext_vtab *) pVtab;
1.1          (drh      31-Aug-06): 
1.5          (drh      02-Sep-06):   TRACE(("FTS1 Update %p\n", pVtab));
1.1          (drh      31-Aug-06):   if( nArg<2 ){
1.1          (drh      31-Aug-06):     return index_delete(v, sqlite3_value_int64(ppArg[0]));
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   if( sqlite3_value_type(ppArg[0]) != SQLITE_NULL ){
1.1          (drh      31-Aug-06):     return SQLITE_ERROR;   /* an update; not yet supported */
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.14         (adamd    13-Sep-06):   /* ppArg[1] = rowid
1.16         (drh      13-Sep-06):    * ppArg[2..2+v->nColumn-1] = values
1.20         (drh      14-Sep-06):    * ppArg[2+v->nColumn] = value for _all (we ignore this)
1.20         (drh      14-Sep-06):    * ppArg[3+v->nColumn] = value of offset (we ignore this too)
1.20         (drh      14-Sep-06):    */
1.23         (drh      18-Sep-06):   assert( nArg==2+v->nColumn+1);    
1.14         (adamd    13-Sep-06): 
1.14         (adamd    13-Sep-06):   return index_insert(v, ppArg[1], &ppArg[2], pRowid);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.23         (drh      18-Sep-06): /*
1.23         (drh      18-Sep-06): ** Implementation of the snippet() function for FTS1
1.23         (drh      18-Sep-06): */
1.23         (drh      18-Sep-06): static void snippetFunc(
1.23         (drh      18-Sep-06):   sqlite3_context *pContext,
1.23         (drh      18-Sep-06):   int argc,
1.23         (drh      18-Sep-06):   sqlite3_value **argv
1.23         (drh      18-Sep-06): ){
1.23         (drh      18-Sep-06):   fulltext_cursor *pCursor;
1.23         (drh      18-Sep-06):   if( argc<1 ) return;
1.23         (drh      18-Sep-06):   if( sqlite3_value_type(argv[0])!=SQLITE_BLOB ||
1.23         (drh      18-Sep-06):       sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){
1.23         (drh      18-Sep-06):     sqlite3_result_error(pContext, "illegal first argument to html_snippet",-1);
1.23         (drh      18-Sep-06):   }else{
1.26         (drh      21-Sep-06):     const char *zStart = "<b>";
1.26         (drh      21-Sep-06):     const char *zEnd = "</b>";
1.26         (drh      21-Sep-06):     const char *zEllipsis = "<b>...</b>";
1.23         (drh      18-Sep-06):     memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor));
1.26         (drh      21-Sep-06):     if( argc>=2 ){
1.26         (drh      21-Sep-06):       zStart = (const char*)sqlite3_value_text(argv[1]);
1.26         (drh      21-Sep-06):       if( argc>=3 ){
1.26         (drh      21-Sep-06):         zEnd = (const char*)sqlite3_value_text(argv[2]);
1.26         (drh      21-Sep-06):         if( argc>=4 ){
1.26         (drh      21-Sep-06):           zEllipsis = (const char*)sqlite3_value_text(argv[3]);
1.26         (drh      21-Sep-06):         }
1.26         (drh      21-Sep-06):       }
1.26         (drh      21-Sep-06):     }
1.26         (drh      21-Sep-06):     snippetAllOffsets(pCursor);
1.26         (drh      21-Sep-06):     snippetText(pCursor, zStart, zEnd, zEllipsis);
1.26         (drh      21-Sep-06):     sqlite3_result_text(pContext, pCursor->snippet.zSnippet,
1.26         (drh      21-Sep-06):                         pCursor->snippet.nSnippet, SQLITE_STATIC);
1.23         (drh      18-Sep-06):   }
1.23         (drh      18-Sep-06): }
1.23         (drh      18-Sep-06): 
1.23         (drh      18-Sep-06): /*
1.23         (drh      18-Sep-06): ** Implementation of the offsets() function for FTS1
1.23         (drh      18-Sep-06): */
1.23         (drh      18-Sep-06): static void snippetOffsetsFunc(
1.23         (drh      18-Sep-06):   sqlite3_context *pContext,
1.23         (drh      18-Sep-06):   int argc,
1.23         (drh      18-Sep-06):   sqlite3_value **argv
1.23         (drh      18-Sep-06): ){
1.23         (drh      18-Sep-06):   fulltext_cursor *pCursor;
1.23         (drh      18-Sep-06):   if( argc<1 ) return;
1.23         (drh      18-Sep-06):   if( sqlite3_value_type(argv[0])!=SQLITE_BLOB ||
1.23         (drh      18-Sep-06):       sqlite3_value_bytes(argv[0])!=sizeof(pCursor) ){
1.23         (drh      18-Sep-06):     sqlite3_result_error(pContext, "illegal first argument to offsets",-1);
1.23         (drh      18-Sep-06):   }else{
1.23         (drh      18-Sep-06):     memcpy(&pCursor, sqlite3_value_blob(argv[0]), sizeof(pCursor));
1.23         (drh      18-Sep-06):     snippetAllOffsets(pCursor);
1.23         (drh      18-Sep-06):     snippetOffsetText(&pCursor->snippet);
1.23         (drh      18-Sep-06):     sqlite3_result_text(pContext,
1.23         (drh      18-Sep-06):                         pCursor->snippet.zOffset, pCursor->snippet.nOffset,
1.23         (drh      18-Sep-06):                         SQLITE_STATIC);
1.23         (drh      18-Sep-06):   }
1.23         (drh      18-Sep-06): }
1.23         (drh      18-Sep-06): 
1.23         (drh      18-Sep-06): /*
1.23         (drh      18-Sep-06): ** This routine implements the xFindFunction method for the FTS1
1.23         (drh      18-Sep-06): ** virtual table.
1.23         (drh      18-Sep-06): */
1.23         (drh      18-Sep-06): static int fulltextFindFunction(
1.23         (drh      18-Sep-06):   sqlite3_vtab *pVtab,
1.23         (drh      18-Sep-06):   int nArg,
1.23         (drh      18-Sep-06):   const char *zName,
1.23         (drh      18-Sep-06):   void (**pxFunc)(sqlite3_context*,int,sqlite3_value**),
1.23         (drh      18-Sep-06):   void **ppArg
1.23         (drh      18-Sep-06): ){
1.24         (drh      18-Sep-06):   if( strcmp(zName,"snippet")==0 ){
1.23         (drh      18-Sep-06):     *pxFunc = snippetFunc;
1.23         (drh      18-Sep-06):     return 1;
1.24         (drh      18-Sep-06):   }else if( strcmp(zName,"offsets")==0 ){
1.23         (drh      18-Sep-06):     *pxFunc = snippetOffsetsFunc;
1.23         (drh      18-Sep-06):     return 1;
1.23         (drh      18-Sep-06):   }
1.23         (drh      18-Sep-06):   return 0;
1.23         (drh      18-Sep-06): }
1.23         (drh      18-Sep-06): 
1.4          (drh      02-Sep-06): static const sqlite3_module fulltextModule = {
1.20         (drh      14-Sep-06):   /* iVersion      */ 0,
1.20         (drh      14-Sep-06):   /* xCreate       */ fulltextCreate,
1.20         (drh      14-Sep-06):   /* xConnect      */ fulltextConnect,
1.20         (drh      14-Sep-06):   /* xBestIndex    */ fulltextBestIndex,
1.20         (drh      14-Sep-06):   /* xDisconnect   */ fulltextDisconnect,
1.20         (drh      14-Sep-06):   /* xDestroy      */ fulltextDestroy,
1.20         (drh      14-Sep-06):   /* xOpen         */ fulltextOpen,
1.20         (drh      14-Sep-06):   /* xClose        */ fulltextClose,
1.20         (drh      14-Sep-06):   /* xFilter       */ fulltextFilter,
1.20         (drh      14-Sep-06):   /* xNext         */ fulltextNext,
1.20         (drh      14-Sep-06):   /* xEof          */ fulltextEof,
1.20         (drh      14-Sep-06):   /* xColumn       */ fulltextColumn,
1.20         (drh      14-Sep-06):   /* xRowid        */ fulltextRowid,
1.20         (drh      14-Sep-06):   /* xUpdate       */ fulltextUpdate,
1.20         (drh      14-Sep-06):   /* xBegin        */ 0, 
1.20         (drh      14-Sep-06):   /* xSync         */ 0,
1.20         (drh      14-Sep-06):   /* xCommit       */ 0,
1.20         (drh      14-Sep-06):   /* xRollback     */ 0,
1.23         (drh      18-Sep-06):   /* xFindFunction */ fulltextFindFunction,
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): int sqlite3Fts1Init(sqlite3 *db){
1.23         (drh      18-Sep-06):   sqlite3_overload_function(db, "snippet", -1);
1.23         (drh      18-Sep-06):   sqlite3_overload_function(db, "offsets", -1);
1.23         (drh      18-Sep-06):   return sqlite3_create_module(db, "fts1", &fulltextModule, 0);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #if !SQLITE_CORE
1.1          (drh      31-Aug-06): int sqlite3_extension_init(sqlite3 *db, char **pzErrMsg,
1.1          (drh      31-Aug-06):                            const sqlite3_api_routines *pApi){
1.23         (drh      18-Sep-06):   SQLITE_EXTENSION_INIT2(pApi)
1.25         (adamd    18-Sep-06):   return sqlite3Fts1Init(db);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): #endif
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1) */
1.1          (drh      31-Aug-06): #include "sqlite3.h"
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #ifdef __cplusplus
1.1          (drh      31-Aug-06): extern "C" {
1.1          (drh      31-Aug-06): #endif  /* __cplusplus */
1.1          (drh      31-Aug-06): 
1.2          (shess    13-Sep-06): int sqlite3Fts1Init(sqlite3 *db);
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #ifdef __cplusplus
1.1          (drh      31-Aug-06): }  /* extern "C" */
1.1          (drh      31-Aug-06): #endif  /* __cplusplus */
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** 2001 September 22
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** The author disclaims copyright to this source code.  In place of
1.1          (drh      31-Aug-06): ** a legal notice, here is a blessing:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **    May you do good and not evil.
1.1          (drh      31-Aug-06): **    May you find forgiveness for yourself and forgive others.
1.1          (drh      31-Aug-06): **    May you share freely, never taking more than you give.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): *************************************************************************
1.1          (drh      31-Aug-06): ** This is the implementation of generic hash-tables used in SQLite.
1.1          (drh      31-Aug-06): ** We've modified it slightly to serve as a standalone hash table
1.1          (drh      31-Aug-06): ** implementation for the full-text indexing module.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #include <assert.h>
1.1          (drh      31-Aug-06): #include <stdlib.h>
1.1          (drh      31-Aug-06): #include <string.h>
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** The code in this file is only compiled if:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **     * The FTS1 module is being built as an extension
1.1          (drh      31-Aug-06): **       (in which case SQLITE_CORE is not defined), or
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **     * The FTS1 module is being built into the core of
1.1          (drh      31-Aug-06): **       SQLite (in which case SQLITE_ENABLE_FTS1 is defined).
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #include "fts1_hash.h"
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static void *malloc_and_zero(int n){
1.1          (drh      31-Aug-06):   void *p = malloc(n);
1.1          (drh      31-Aug-06):   if( p ){
1.1          (drh      31-Aug-06):     memset(p, 0, n);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return p;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Turn bulk memory into a hash table object by initializing the
1.1          (drh      31-Aug-06): ** fields of the Hash structure.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** "pNew" is a pointer to the hash table that is to be initialized.
1.1          (drh      31-Aug-06): ** keyClass is one of the constants 
1.1          (drh      31-Aug-06): ** FTS1_HASH_BINARY or FTS1_HASH_STRING.  The value of keyClass 
1.1          (drh      31-Aug-06): ** determines what kind of key the hash table will use.  "copyKey" is
1.1          (drh      31-Aug-06): ** true if the hash table should make its own private copy of keys and
1.1          (drh      31-Aug-06): ** false if it should just use the supplied pointer.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): void sqlite3Fts1HashInit(fts1Hash *pNew, int keyClass, int copyKey){
1.1          (drh      31-Aug-06):   assert( pNew!=0 );
1.1          (drh      31-Aug-06):   assert( keyClass>=FTS1_HASH_STRING && keyClass<=FTS1_HASH_BINARY );
1.1          (drh      31-Aug-06):   pNew->keyClass = keyClass;
1.1          (drh      31-Aug-06):   pNew->copyKey = copyKey;
1.1          (drh      31-Aug-06):   pNew->first = 0;
1.1          (drh      31-Aug-06):   pNew->count = 0;
1.1          (drh      31-Aug-06):   pNew->htsize = 0;
1.1          (drh      31-Aug-06):   pNew->ht = 0;
1.1          (drh      31-Aug-06):   pNew->xMalloc = malloc_and_zero;
1.1          (drh      31-Aug-06):   pNew->xFree = free;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Remove all entries from a hash table.  Reclaim all memory.
1.1          (drh      31-Aug-06): ** Call this routine to delete a hash table or to reset a hash table
1.1          (drh      31-Aug-06): ** to the empty state.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): void sqlite3Fts1HashClear(fts1Hash *pH){
1.1          (drh      31-Aug-06):   fts1HashElem *elem;         /* For looping over all elements of the table */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   assert( pH!=0 );
1.1          (drh      31-Aug-06):   elem = pH->first;
1.1          (drh      31-Aug-06):   pH->first = 0;
1.1          (drh      31-Aug-06):   if( pH->ht ) pH->xFree(pH->ht);
1.1          (drh      31-Aug-06):   pH->ht = 0;
1.1          (drh      31-Aug-06):   pH->htsize = 0;
1.1          (drh      31-Aug-06):   while( elem ){
1.1          (drh      31-Aug-06):     fts1HashElem *next_elem = elem->next;
1.1          (drh      31-Aug-06):     if( pH->copyKey && elem->pKey ){
1.1          (drh      31-Aug-06):       pH->xFree(elem->pKey);
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):     pH->xFree(elem);
1.1          (drh      31-Aug-06):     elem = next_elem;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   pH->count = 0;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Hash and comparison functions when the mode is FTS1_HASH_STRING
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int strHash(const void *pKey, int nKey){
1.1          (drh      31-Aug-06):   const char *z = (const char *)pKey;
1.1          (drh      31-Aug-06):   int h = 0;
1.1          (drh      31-Aug-06):   if( nKey<=0 ) nKey = (int) strlen(z);
1.1          (drh      31-Aug-06):   while( nKey > 0  ){
1.1          (drh      31-Aug-06):     h = (h<<3) ^ h ^ *z++;
1.1          (drh      31-Aug-06):     nKey--;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return h & 0x7fffffff;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): static int strCompare(const void *pKey1, int n1, const void *pKey2, int n2){
1.1          (drh      31-Aug-06):   if( n1!=n2 ) return 1;
1.1          (drh      31-Aug-06):   return strncmp((const char*)pKey1,(const char*)pKey2,n1);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Hash and comparison functions when the mode is FTS1_HASH_BINARY
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int binHash(const void *pKey, int nKey){
1.1          (drh      31-Aug-06):   int h = 0;
1.1          (drh      31-Aug-06):   const char *z = (const char *)pKey;
1.1          (drh      31-Aug-06):   while( nKey-- > 0 ){
1.1          (drh      31-Aug-06):     h = (h<<3) ^ h ^ *(z++);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return h & 0x7fffffff;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): static int binCompare(const void *pKey1, int n1, const void *pKey2, int n2){
1.1          (drh      31-Aug-06):   if( n1!=n2 ) return 1;
1.1          (drh      31-Aug-06):   return memcmp(pKey1,pKey2,n1);
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Return a pointer to the appropriate hash function given the key class.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** The C syntax in this function definition may be unfamilar to some 
1.1          (drh      31-Aug-06): ** programmers, so we provide the following additional explanation:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** The name of the function is "hashFunction".  The function takes a
1.1          (drh      31-Aug-06): ** single parameter "keyClass".  The return value of hashFunction()
1.1          (drh      31-Aug-06): ** is a pointer to another function.  Specifically, the return value
1.1          (drh      31-Aug-06): ** of hashFunction() is a pointer to a function that takes two parameters
1.1          (drh      31-Aug-06): ** with types "const void*" and "int" and returns an "int".
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int (*hashFunction(int keyClass))(const void*,int){
1.1          (drh      31-Aug-06):   if( keyClass==FTS1_HASH_STRING ){
1.1          (drh      31-Aug-06):     return &strHash;
1.1          (drh      31-Aug-06):   }else{
1.1          (drh      31-Aug-06):     assert( keyClass==FTS1_HASH_BINARY );
1.1          (drh      31-Aug-06):     return &binHash;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Return a pointer to the appropriate hash function given the key class.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** For help in interpreted the obscure C code in the function definition,
1.1          (drh      31-Aug-06): ** see the header comment on the previous function.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static int (*compareFunction(int keyClass))(const void*,int,const void*,int){
1.1          (drh      31-Aug-06):   if( keyClass==FTS1_HASH_STRING ){
1.1          (drh      31-Aug-06):     return &strCompare;
1.1          (drh      31-Aug-06):   }else{
1.1          (drh      31-Aug-06):     assert( keyClass==FTS1_HASH_BINARY );
1.1          (drh      31-Aug-06):     return &binCompare;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Link an element into the hash table
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static void insertElement(
1.1          (drh      31-Aug-06):   fts1Hash *pH,            /* The complete hash table */
1.1          (drh      31-Aug-06):   struct _fts1ht *pEntry,  /* The entry into which pNew is inserted */
1.1          (drh      31-Aug-06):   fts1HashElem *pNew       /* The element to be inserted */
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   fts1HashElem *pHead;     /* First element already in pEntry */
1.1          (drh      31-Aug-06):   pHead = pEntry->chain;
1.1          (drh      31-Aug-06):   if( pHead ){
1.1          (drh      31-Aug-06):     pNew->next = pHead;
1.1          (drh      31-Aug-06):     pNew->prev = pHead->prev;
1.1          (drh      31-Aug-06):     if( pHead->prev ){ pHead->prev->next = pNew; }
1.1          (drh      31-Aug-06):     else             { pH->first = pNew; }
1.1          (drh      31-Aug-06):     pHead->prev = pNew;
1.1          (drh      31-Aug-06):   }else{
1.1          (drh      31-Aug-06):     pNew->next = pH->first;
1.1          (drh      31-Aug-06):     if( pH->first ){ pH->first->prev = pNew; }
1.1          (drh      31-Aug-06):     pNew->prev = 0;
1.1          (drh      31-Aug-06):     pH->first = pNew;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   pEntry->count++;
1.1          (drh      31-Aug-06):   pEntry->chain = pNew;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Resize the hash table so that it cantains "new_size" buckets.
1.1          (drh      31-Aug-06): ** "new_size" must be a power of 2.  The hash table might fail 
1.1          (drh      31-Aug-06): ** to resize if sqliteMalloc() fails.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static void rehash(fts1Hash *pH, int new_size){
1.1          (drh      31-Aug-06):   struct _fts1ht *new_ht;          /* The new hash table */
1.1          (drh      31-Aug-06):   fts1HashElem *elem, *next_elem;  /* For looping over existing elements */
1.1          (drh      31-Aug-06):   int (*xHash)(const void*,int);   /* The hash function */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   assert( (new_size & (new_size-1))==0 );
1.1          (drh      31-Aug-06):   new_ht = (struct _fts1ht *)pH->xMalloc( new_size*sizeof(struct _fts1ht) );
1.1          (drh      31-Aug-06):   if( new_ht==0 ) return;
1.1          (drh      31-Aug-06):   if( pH->ht ) pH->xFree(pH->ht);
1.1          (drh      31-Aug-06):   pH->ht = new_ht;
1.1          (drh      31-Aug-06):   pH->htsize = new_size;
1.1          (drh      31-Aug-06):   xHash = hashFunction(pH->keyClass);
1.1          (drh      31-Aug-06):   for(elem=pH->first, pH->first=0; elem; elem = next_elem){
1.1          (drh      31-Aug-06):     int h = (*xHash)(elem->pKey, elem->nKey) & (new_size-1);
1.1          (drh      31-Aug-06):     next_elem = elem->next;
1.1          (drh      31-Aug-06):     insertElement(pH, &new_ht[h], elem);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* This function (for internal use only) locates an element in an
1.1          (drh      31-Aug-06): ** hash table that matches the given key.  The hash for this key has
1.1          (drh      31-Aug-06): ** already been computed and is passed as the 4th parameter.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static fts1HashElem *findElementGivenHash(
1.1          (drh      31-Aug-06):   const fts1Hash *pH, /* The pH to be searched */
1.1          (drh      31-Aug-06):   const void *pKey,   /* The key we are searching for */
1.1          (drh      31-Aug-06):   int nKey,
1.1          (drh      31-Aug-06):   int h               /* The hash for this key. */
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   fts1HashElem *elem;            /* Used to loop thru the element list */
1.1          (drh      31-Aug-06):   int count;                     /* Number of elements left to test */
1.1          (drh      31-Aug-06):   int (*xCompare)(const void*,int,const void*,int);  /* comparison function */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   if( pH->ht ){
1.1          (drh      31-Aug-06):     struct _fts1ht *pEntry = &pH->ht[h];
1.1          (drh      31-Aug-06):     elem = pEntry->chain;
1.1          (drh      31-Aug-06):     count = pEntry->count;
1.1          (drh      31-Aug-06):     xCompare = compareFunction(pH->keyClass);
1.1          (drh      31-Aug-06):     while( count-- && elem ){
1.1          (drh      31-Aug-06):       if( (*xCompare)(elem->pKey,elem->nKey,pKey,nKey)==0 ){ 
1.1          (drh      31-Aug-06):         return elem;
1.1          (drh      31-Aug-06):       }
1.1          (drh      31-Aug-06):       elem = elem->next;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return 0;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Remove a single entry from the hash table given a pointer to that
1.1          (drh      31-Aug-06): ** element and a hash on the element's key.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): static void removeElementGivenHash(
1.1          (drh      31-Aug-06):   fts1Hash *pH,         /* The pH containing "elem" */
1.1          (drh      31-Aug-06):   fts1HashElem* elem,   /* The element to be removed from the pH */
1.1          (drh      31-Aug-06):   int h                 /* Hash value for the element */
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   struct _fts1ht *pEntry;
1.1          (drh      31-Aug-06):   if( elem->prev ){
1.1          (drh      31-Aug-06):     elem->prev->next = elem->next; 
1.1          (drh      31-Aug-06):   }else{
1.1          (drh      31-Aug-06):     pH->first = elem->next;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   if( elem->next ){
1.1          (drh      31-Aug-06):     elem->next->prev = elem->prev;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   pEntry = &pH->ht[h];
1.1          (drh      31-Aug-06):   if( pEntry->chain==elem ){
1.1          (drh      31-Aug-06):     pEntry->chain = elem->next;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   pEntry->count--;
1.1          (drh      31-Aug-06):   if( pEntry->count<=0 ){
1.1          (drh      31-Aug-06):     pEntry->chain = 0;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   if( pH->copyKey && elem->pKey ){
1.1          (drh      31-Aug-06):     pH->xFree(elem->pKey);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   pH->xFree( elem );
1.1          (drh      31-Aug-06):   pH->count--;
1.1          (drh      31-Aug-06):   if( pH->count<=0 ){
1.1          (drh      31-Aug-06):     assert( pH->first==0 );
1.1          (drh      31-Aug-06):     assert( pH->count==0 );
1.1          (drh      31-Aug-06):     fts1HashClear(pH);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Attempt to locate an element of the hash table pH with a key
1.1          (drh      31-Aug-06): ** that matches pKey,nKey.  Return the data for this element if it is
1.1          (drh      31-Aug-06): ** found, or NULL if there is no match.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): void *sqlite3Fts1HashFind(const fts1Hash *pH, const void *pKey, int nKey){
1.1          (drh      31-Aug-06):   int h;                 /* A hash on key */
1.1          (drh      31-Aug-06):   fts1HashElem *elem;    /* The element that matches key */
1.1          (drh      31-Aug-06):   int (*xHash)(const void*,int);  /* The hash function */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   if( pH==0 || pH->ht==0 ) return 0;
1.1          (drh      31-Aug-06):   xHash = hashFunction(pH->keyClass);
1.1          (drh      31-Aug-06):   assert( xHash!=0 );
1.1          (drh      31-Aug-06):   h = (*xHash)(pKey,nKey);
1.1          (drh      31-Aug-06):   assert( (pH->htsize & (pH->htsize-1))==0 );
1.1          (drh      31-Aug-06):   elem = findElementGivenHash(pH,pKey,nKey, h & (pH->htsize-1));
1.1          (drh      31-Aug-06):   return elem ? elem->data : 0;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Insert an element into the hash table pH.  The key is pKey,nKey
1.1          (drh      31-Aug-06): ** and the data is "data".
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** If no element exists with a matching key, then a new
1.1          (drh      31-Aug-06): ** element is created.  A copy of the key is made if the copyKey
1.1          (drh      31-Aug-06): ** flag is set.  NULL is returned.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** If another element already exists with the same key, then the
1.1          (drh      31-Aug-06): ** new data replaces the old data and the old data is returned.
1.1          (drh      31-Aug-06): ** The key is not copied in this instance.  If a malloc fails, then
1.1          (drh      31-Aug-06): ** the new data is returned and the hash table is unchanged.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** If the "data" parameter to this function is NULL, then the
1.1          (drh      31-Aug-06): ** element corresponding to "key" is removed from the hash table.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): void *sqlite3Fts1HashInsert(
1.1          (drh      31-Aug-06):   fts1Hash *pH,        /* The hash table to insert into */
1.1          (drh      31-Aug-06):   const void *pKey,    /* The key */
1.1          (drh      31-Aug-06):   int nKey,            /* Number of bytes in the key */
1.1          (drh      31-Aug-06):   void *data           /* The data */
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   int hraw;                 /* Raw hash value of the key */
1.1          (drh      31-Aug-06):   int h;                    /* the hash of the key modulo hash table size */
1.1          (drh      31-Aug-06):   fts1HashElem *elem;       /* Used to loop thru the element list */
1.1          (drh      31-Aug-06):   fts1HashElem *new_elem;   /* New element added to the pH */
1.1          (drh      31-Aug-06):   int (*xHash)(const void*,int);  /* The hash function */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   assert( pH!=0 );
1.1          (drh      31-Aug-06):   xHash = hashFunction(pH->keyClass);
1.1          (drh      31-Aug-06):   assert( xHash!=0 );
1.1          (drh      31-Aug-06):   hraw = (*xHash)(pKey, nKey);
1.1          (drh      31-Aug-06):   assert( (pH->htsize & (pH->htsize-1))==0 );
1.1          (drh      31-Aug-06):   h = hraw & (pH->htsize-1);
1.1          (drh      31-Aug-06):   elem = findElementGivenHash(pH,pKey,nKey,h);
1.1          (drh      31-Aug-06):   if( elem ){
1.1          (drh      31-Aug-06):     void *old_data = elem->data;
1.1          (drh      31-Aug-06):     if( data==0 ){
1.1          (drh      31-Aug-06):       removeElementGivenHash(pH,elem,h);
1.1          (drh      31-Aug-06):     }else{
1.1          (drh      31-Aug-06):       elem->data = data;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):     return old_data;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   if( data==0 ) return 0;
1.1          (drh      31-Aug-06):   new_elem = (fts1HashElem*)pH->xMalloc( sizeof(fts1HashElem) );
1.1          (drh      31-Aug-06):   if( new_elem==0 ) return data;
1.1          (drh      31-Aug-06):   if( pH->copyKey && pKey!=0 ){
1.1          (drh      31-Aug-06):     new_elem->pKey = pH->xMalloc( nKey );
1.1          (drh      31-Aug-06):     if( new_elem->pKey==0 ){
1.1          (drh      31-Aug-06):       pH->xFree(new_elem);
1.1          (drh      31-Aug-06):       return data;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):     memcpy((void*)new_elem->pKey, pKey, nKey);
1.1          (drh      31-Aug-06):   }else{
1.1          (drh      31-Aug-06):     new_elem->pKey = (void*)pKey;
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   new_elem->nKey = nKey;
1.1          (drh      31-Aug-06):   pH->count++;
1.1          (drh      31-Aug-06):   if( pH->htsize==0 ){
1.1          (drh      31-Aug-06):     rehash(pH,8);
1.1          (drh      31-Aug-06):     if( pH->htsize==0 ){
1.1          (drh      31-Aug-06):       pH->count = 0;
1.1          (drh      31-Aug-06):       pH->xFree(new_elem);
1.1          (drh      31-Aug-06):       return data;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   if( pH->count > pH->htsize ){
1.1          (drh      31-Aug-06):     rehash(pH,pH->htsize*2);
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   assert( pH->htsize>0 );
1.1          (drh      31-Aug-06):   assert( (pH->htsize & (pH->htsize-1))==0 );
1.1          (drh      31-Aug-06):   h = hraw & (pH->htsize-1);
1.1          (drh      31-Aug-06):   insertElement(pH, &pH->ht[h], new_elem);
1.1          (drh      31-Aug-06):   new_elem->data = data;
1.1          (drh      31-Aug-06):   return 0;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1) */
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** 2001 September 22
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** The author disclaims copyright to this source code.  In place of
1.1          (drh      31-Aug-06): ** a legal notice, here is a blessing:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **    May you do good and not evil.
1.1          (drh      31-Aug-06): **    May you find forgiveness for yourself and forgive others.
1.1          (drh      31-Aug-06): **    May you share freely, never taking more than you give.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): *************************************************************************
1.1          (drh      31-Aug-06): ** This is the header file for the generic hash-table implemenation
1.1          (drh      31-Aug-06): ** used in SQLite.  We've modified it slightly to serve as a standalone
1.1          (drh      31-Aug-06): ** hash table implementation for the full-text indexing module.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #ifndef _FTS1_HASH_H_
1.1          (drh      31-Aug-06): #define _FTS1_HASH_H_
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Forward declarations of structures. */
1.1          (drh      31-Aug-06): typedef struct fts1Hash fts1Hash;
1.1          (drh      31-Aug-06): typedef struct fts1HashElem fts1HashElem;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* A complete hash table is an instance of the following structure.
1.1          (drh      31-Aug-06): ** The internals of this structure are intended to be opaque -- client
1.1          (drh      31-Aug-06): ** code should not attempt to access or modify the fields of this structure
1.1          (drh      31-Aug-06): ** directly.  Change this structure only by using the routines below.
1.1          (drh      31-Aug-06): ** However, many of the "procedures" and "functions" for modifying and
1.1          (drh      31-Aug-06): ** accessing this structure are really macros, so we can't really make
1.1          (drh      31-Aug-06): ** this structure opaque.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): struct fts1Hash {
1.1          (drh      31-Aug-06):   char keyClass;          /* HASH_INT, _POINTER, _STRING, _BINARY */
1.1          (drh      31-Aug-06):   char copyKey;           /* True if copy of key made on insert */
1.1          (drh      31-Aug-06):   int count;              /* Number of entries in this table */
1.1          (drh      31-Aug-06):   fts1HashElem *first;    /* The first element of the array */
1.1          (drh      31-Aug-06):   void *(*xMalloc)(int);  /* malloc() function to use */
1.1          (drh      31-Aug-06):   void (*xFree)(void *);  /* free() function to use */
1.1          (drh      31-Aug-06):   int htsize;             /* Number of buckets in the hash table */
1.1          (drh      31-Aug-06):   struct _fts1ht {        /* the hash table */
1.1          (drh      31-Aug-06):     int count;               /* Number of entries with this hash */
1.1          (drh      31-Aug-06):     fts1HashElem *chain;     /* Pointer to first entry with this hash */
1.1          (drh      31-Aug-06):   } *ht;
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* Each element in the hash table is an instance of the following 
1.1          (drh      31-Aug-06): ** structure.  All elements are stored on a single doubly-linked list.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** Again, this structure is intended to be opaque, but it can't really
1.1          (drh      31-Aug-06): ** be opaque because it is used by macros.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): struct fts1HashElem {
1.1          (drh      31-Aug-06):   fts1HashElem *next, *prev; /* Next and previous elements in the table */
1.1          (drh      31-Aug-06):   void *data;                /* Data associated with this element */
1.1          (drh      31-Aug-06):   void *pKey; int nKey;      /* Key associated with this element */
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** There are 2 different modes of operation for a hash table:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **   FTS1_HASH_STRING        pKey points to a string that is nKey bytes long
1.1          (drh      31-Aug-06): **                           (including the null-terminator, if any).  Case
1.1          (drh      31-Aug-06): **                           is respected in comparisons.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **   FTS1_HASH_BINARY        pKey points to binary data nKey bytes long. 
1.1          (drh      31-Aug-06): **                           memcmp() is used to compare keys.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** A copy of the key is made if the copyKey parameter to fts1HashInit is 1.  
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #define FTS1_HASH_STRING    1
1.1          (drh      31-Aug-06): #define FTS1_HASH_BINARY    2
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Access routines.  To delete, insert a NULL pointer.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): void sqlite3Fts1HashInit(fts1Hash*, int keytype, int copyKey);
1.1          (drh      31-Aug-06): void *sqlite3Fts1HashInsert(fts1Hash*, const void *pKey, int nKey, void *pData);
1.1          (drh      31-Aug-06): void *sqlite3Fts1HashFind(const fts1Hash*, const void *pKey, int nKey);
1.1          (drh      31-Aug-06): void sqlite3Fts1HashClear(fts1Hash*);
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Shorthand for the functions above
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #define fts1HashInit   sqlite3Fts1HashInit
1.1          (drh      31-Aug-06): #define fts1HashInsert sqlite3Fts1HashInsert
1.1          (drh      31-Aug-06): #define fts1HashFind   sqlite3Fts1HashFind
1.1          (drh      31-Aug-06): #define fts1HashClear  sqlite3Fts1HashClear
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Macros for looping over all elements of a hash table.  The idiom is
1.1          (drh      31-Aug-06): ** like this:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **   fts1Hash h;
1.1          (drh      31-Aug-06): **   fts1HashElem *p;
1.1          (drh      31-Aug-06): **   ...
1.1          (drh      31-Aug-06): **   for(p=fts1HashFirst(&h); p; p=fts1HashNext(p)){
1.1          (drh      31-Aug-06): **     SomeStructure *pData = fts1HashData(p);
1.1          (drh      31-Aug-06): **     // do something with pData
1.1          (drh      31-Aug-06): **   }
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #define fts1HashFirst(H)  ((H)->first)
1.1          (drh      31-Aug-06): #define fts1HashNext(E)   ((E)->next)
1.1          (drh      31-Aug-06): #define fts1HashData(E)   ((E)->data)
1.1          (drh      31-Aug-06): #define fts1HashKey(E)    ((E)->pKey)
1.1          (drh      31-Aug-06): #define fts1HashKeysize(E) ((E)->nKey)
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Number of entries in a hash table
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #define fts1HashCount(H)  ((H)->count)
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #endif /* _FTS1_HASH_H_ */
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** 2006 July 10
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** The author disclaims copyright to this source code.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): *************************************************************************
1.1          (drh      31-Aug-06): ** Defines the interface to tokenizers used by fulltext-search.  There
1.1          (drh      31-Aug-06): ** are three basic components:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** sqlite3_tokenizer_module is a singleton defining the tokenizer
1.1          (drh      31-Aug-06): ** interface functions.  This is essentially the class structure for
1.1          (drh      31-Aug-06): ** tokenizers.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** sqlite3_tokenizer is used to define a particular tokenizer, perhaps
1.1          (drh      31-Aug-06): ** including customization information defined at creation time.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): ** sqlite3_tokenizer_cursor is generated by a tokenizer to generate
1.1          (drh      31-Aug-06): ** tokens from a particular input.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #ifndef _FTS1_TOKENIZER_H_
1.1          (drh      31-Aug-06): #define _FTS1_TOKENIZER_H_
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /* TODO(shess) Only used for SQLITE_OK and SQLITE_DONE at this time.
1.1          (drh      31-Aug-06): ** If tokenizers are to be allowed to call sqlite3_*() functions, then
1.1          (drh      31-Aug-06): ** we will need a way to register the API consistently.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #include "sqlite3.h"
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Structures used by the tokenizer interface.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): typedef struct sqlite3_tokenizer sqlite3_tokenizer;
1.1          (drh      31-Aug-06): typedef struct sqlite3_tokenizer_cursor sqlite3_tokenizer_cursor;
1.1          (drh      31-Aug-06): typedef struct sqlite3_tokenizer_module sqlite3_tokenizer_module;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): struct sqlite3_tokenizer_module {
1.1          (drh      31-Aug-06):   int iVersion;                  /* currently 0 */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /*
1.1          (drh      31-Aug-06):   ** Create and destroy a tokenizer.  argc/argv are passed down from
1.1          (drh      31-Aug-06):   ** the fulltext virtual table creation to allow customization.
1.1          (drh      31-Aug-06):   */
1.3          (drh      11-Sep-06):   int (*xCreate)(int argc, const char *const*argv,
1.1          (drh      31-Aug-06):                  sqlite3_tokenizer **ppTokenizer);
1.1          (drh      31-Aug-06):   int (*xDestroy)(sqlite3_tokenizer *pTokenizer);
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   /*
1.1          (drh      31-Aug-06):   ** Tokenize a particular input.  Call xOpen() to prepare to
1.1          (drh      31-Aug-06):   ** tokenize, xNext() repeatedly until it returns SQLITE_DONE, then
1.1          (drh      31-Aug-06):   ** xClose() to free any internal state.  The pInput passed to
1.1          (drh      31-Aug-06):   ** xOpen() must exist until the cursor is closed.  The ppToken
1.1          (drh      31-Aug-06):   ** result from xNext() is only valid until the next call to xNext()
1.1          (drh      31-Aug-06):   ** or until xClose() is called.
1.1          (drh      31-Aug-06):   */
1.1          (drh      31-Aug-06):   /* TODO(shess) current implementation requires pInput to be
1.1          (drh      31-Aug-06):   ** nul-terminated.  This should either be fixed, or pInput/nBytes
1.1          (drh      31-Aug-06):   ** should be converted to zInput.
1.1          (drh      31-Aug-06):   */
1.1          (drh      31-Aug-06):   int (*xOpen)(sqlite3_tokenizer *pTokenizer,
1.1          (drh      31-Aug-06):                const char *pInput, int nBytes,
1.1          (drh      31-Aug-06):                sqlite3_tokenizer_cursor **ppCursor);
1.1          (drh      31-Aug-06):   int (*xClose)(sqlite3_tokenizer_cursor *pCursor);
1.1          (drh      31-Aug-06):   int (*xNext)(sqlite3_tokenizer_cursor *pCursor,
1.1          (drh      31-Aug-06):                const char **ppToken, int *pnBytes,
1.1          (drh      31-Aug-06):                int *piStartOffset, int *piEndOffset, int *piPosition);
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): struct sqlite3_tokenizer {
1.2          (drh      02-Sep-06):   const sqlite3_tokenizer_module *pModule;  /* The module for this tokenizer */
1.1          (drh      31-Aug-06):   /* Tokenizer implementations will typically add additional fields */
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): struct sqlite3_tokenizer_cursor {
1.1          (drh      31-Aug-06):   sqlite3_tokenizer *pTokenizer;       /* Tokenizer for this cursor. */
1.1          (drh      31-Aug-06):   /* Tokenizer implementations will typically add additional fields */
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** Get the module for a tokenizer which generates tokens based on a
1.1          (drh      31-Aug-06): ** set of non-token characters.  The default is to break tokens at any
1.1          (drh      31-Aug-06): ** non-alnum character, though the set of delimiters can also be
1.1          (drh      31-Aug-06): ** specified by the first argv argument to xCreate().
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): /* TODO(shess) This doesn't belong here.  Need some sort of
1.1          (drh      31-Aug-06): ** registration process.
1.1          (drh      31-Aug-06): */
1.2          (drh      02-Sep-06): void sqlite3Fts1SimpleTokenizerModule(sqlite3_tokenizer_module const**ppModule);
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #endif /* _FTS1_TOKENIZER_H_ */
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** The author disclaims copyright to this source code.
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): *************************************************************************
1.1          (drh      31-Aug-06): ** Implementation of the "simple" full-text-search tokenizer.
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): /*
1.1          (drh      31-Aug-06): ** The code in this file is only compiled if:
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **     * The FTS1 module is being built as an extension
1.1          (drh      31-Aug-06): **       (in which case SQLITE_CORE is not defined), or
1.1          (drh      31-Aug-06): **
1.1          (drh      31-Aug-06): **     * The FTS1 module is being built into the core of
1.1          (drh      31-Aug-06): **       SQLite (in which case SQLITE_ENABLE_FTS1 is defined).
1.1          (drh      31-Aug-06): */
1.1          (drh      31-Aug-06): #if !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1)
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #include <assert.h>
1.1          (drh      31-Aug-06): #if !defined(__APPLE__)
1.1          (drh      31-Aug-06): #include <malloc.h>
1.1          (drh      31-Aug-06): #else
1.1          (drh      31-Aug-06): #include <stdlib.h>
1.1          (drh      31-Aug-06): #endif
1.1          (drh      31-Aug-06): #include <stdio.h>
1.1          (drh      31-Aug-06): #include <string.h>
1.1          (drh      31-Aug-06): #include <ctype.h>
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #include "fts1_tokenizer.h"
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): typedef struct simple_tokenizer {
1.1          (drh      31-Aug-06):   sqlite3_tokenizer base;
1.2          (shess    01-Sep-06):   char delim[128];             /* flag ASCII delimiters */
1.1          (drh      31-Aug-06): } simple_tokenizer;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): typedef struct simple_tokenizer_cursor {
1.1          (drh      31-Aug-06):   sqlite3_tokenizer_cursor base;
1.1          (drh      31-Aug-06):   const char *pInput;          /* input we are tokenizing */
1.1          (drh      31-Aug-06):   int nBytes;                  /* size of the input */
1.2          (shess    01-Sep-06):   int iOffset;                 /* current position in pInput */
1.1          (drh      31-Aug-06):   int iToken;                  /* index of next token to be returned */
1.2          (shess    01-Sep-06):   char *pToken;                /* storage for current token */
1.1          (drh      31-Aug-06):   int nTokenAllocated;         /* space allocated to zToken buffer */
1.1          (drh      31-Aug-06): } simple_tokenizer_cursor;
1.1          (drh      31-Aug-06): 
1.3          (drh      02-Sep-06): 
1.3          (drh      02-Sep-06): /* Forward declaration */
1.3          (drh      02-Sep-06): static const sqlite3_tokenizer_module simpleTokenizerModule;
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06): static int isDelim(simple_tokenizer *t, unsigned char c){
1.2          (shess    01-Sep-06):   return c<0x80 && t->delim[c];
1.2          (shess    01-Sep-06): }
1.2          (shess    01-Sep-06): 
1.1          (drh      31-Aug-06): static int simpleCreate(
1.4          (adamd    13-Sep-06):   int argc, const char * const *argv,
1.1          (drh      31-Aug-06):   sqlite3_tokenizer **ppTokenizer
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   simple_tokenizer *t;
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06):   t = (simple_tokenizer *) calloc(sizeof(simple_tokenizer), 1);
1.1          (drh      31-Aug-06):   /* TODO(shess) Delimiters need to remain the same from run to run,
1.1          (drh      31-Aug-06):   ** else we need to reindex.  One solution would be a meta-table to
1.1          (drh      31-Aug-06):   ** track such information in the database, then we'd only want this
1.1          (drh      31-Aug-06):   ** information on the initial create.
1.1          (drh      31-Aug-06):   */
1.1          (drh      31-Aug-06):   if( argc>1 ){
1.2          (shess    01-Sep-06):     int i, n = strlen(argv[1]);
1.2          (shess    01-Sep-06):     for(i=0; i<n; i++){
1.2          (shess    01-Sep-06):       unsigned char ch = argv[1][i];
1.2          (shess    01-Sep-06):       /* We explicitly don't support UTF-8 delimiters for now. */
1.2          (shess    01-Sep-06):       if( ch>=0x80 ){
1.2          (shess    01-Sep-06):         free(t);
1.2          (shess    01-Sep-06):         return SQLITE_ERROR;
1.2          (shess    01-Sep-06):       }
1.2          (shess    01-Sep-06):       t->delim[ch] = 1;
1.2          (shess    01-Sep-06):     }
1.1          (drh      31-Aug-06):   } else {
1.2          (shess    01-Sep-06):     /* Mark non-alphanumeric ASCII characters as delimiters */
1.2          (shess    01-Sep-06):     int i;
1.2          (shess    01-Sep-06):     for(i=1; i<0x80; i++){
1.2          (shess    01-Sep-06):       t->delim[i] = !isalnum(i);
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   *ppTokenizer = &t->base;
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int simpleDestroy(sqlite3_tokenizer *pTokenizer){
1.2          (shess    01-Sep-06):   free(pTokenizer);
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int simpleOpen(
1.1          (drh      31-Aug-06):   sqlite3_tokenizer *pTokenizer,
1.1          (drh      31-Aug-06):   const char *pInput, int nBytes,
1.1          (drh      31-Aug-06):   sqlite3_tokenizer_cursor **ppCursor
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   simple_tokenizer_cursor *c;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   c = (simple_tokenizer_cursor *) malloc(sizeof(simple_tokenizer_cursor));
1.1          (drh      31-Aug-06):   c->pInput = pInput;
1.1          (drh      31-Aug-06):   c->nBytes = nBytes<0 ? (int) strlen(pInput) : nBytes;
1.2          (shess    01-Sep-06):   c->iOffset = 0;                 /* start tokenizing at the beginning */
1.1          (drh      31-Aug-06):   c->iToken = 0;
1.2          (shess    01-Sep-06):   c->pToken = NULL;               /* no space allocated, yet. */
1.1          (drh      31-Aug-06):   c->nTokenAllocated = 0;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):   *ppCursor = &c->base;
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int simpleClose(sqlite3_tokenizer_cursor *pCursor){
1.1          (drh      31-Aug-06):   simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;
1.2          (shess    01-Sep-06):   free(c->pToken);
1.1          (drh      31-Aug-06):   free(c);
1.1          (drh      31-Aug-06):   return SQLITE_OK;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): static int simpleNext(
1.1          (drh      31-Aug-06):   sqlite3_tokenizer_cursor *pCursor,
1.1          (drh      31-Aug-06):   const char **ppToken, int *pnBytes,
1.1          (drh      31-Aug-06):   int *piStartOffset, int *piEndOffset, int *piPosition
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   simple_tokenizer_cursor *c = (simple_tokenizer_cursor *) pCursor;
1.1          (drh      31-Aug-06):   simple_tokenizer *t = (simple_tokenizer *) pCursor->pTokenizer;
1.2          (shess    01-Sep-06):   unsigned char *p = (unsigned char *)c->pInput;
1.2          (shess    01-Sep-06): 
1.2          (shess    01-Sep-06):   while( c->iOffset<c->nBytes ){
1.2          (shess    01-Sep-06):     int iStartOffset;
1.2          (shess    01-Sep-06): 
1.2          (shess    01-Sep-06):     /* Scan past delimiter characters */
1.2          (shess    01-Sep-06):     while( c->iOffset<c->nBytes && isDelim(t, p[c->iOffset]) ){
1.2          (shess    01-Sep-06):       c->iOffset++;
1.2          (shess    01-Sep-06):     }
1.2          (shess    01-Sep-06): 
1.2          (shess    01-Sep-06):     /* Count non-delimiter characters. */
1.2          (shess    01-Sep-06):     iStartOffset = c->iOffset;
1.2          (shess    01-Sep-06):     while( c->iOffset<c->nBytes && !isDelim(t, p[c->iOffset]) ){
1.2          (shess    01-Sep-06):       c->iOffset++;
1.2          (shess    01-Sep-06):     }
1.1          (drh      31-Aug-06): 
1.2          (shess    01-Sep-06):     if( c->iOffset>iStartOffset ){
1.2          (shess    01-Sep-06):       int i, n = c->iOffset-iStartOffset;
1.2          (shess    01-Sep-06):       if( n>c->nTokenAllocated ){
1.2          (shess    01-Sep-06):         c->pToken = realloc(c->pToken, n);
1.1          (drh      31-Aug-06):       }
1.2          (shess    01-Sep-06):       for(i=0; i<n; i++){
1.1          (drh      31-Aug-06):         /* TODO(shess) This needs expansion to handle UTF-8
1.1          (drh      31-Aug-06):         ** case-insensitivity.
1.1          (drh      31-Aug-06):         */
1.2          (shess    01-Sep-06):         unsigned char ch = p[iStartOffset+i];
1.2          (shess    01-Sep-06):         c->pToken[i] = ch<0x80 ? tolower(ch) : ch;
1.1          (drh      31-Aug-06):       }
1.2          (shess    01-Sep-06):       *ppToken = c->pToken;
1.1          (drh      31-Aug-06):       *pnBytes = n;
1.2          (shess    01-Sep-06):       *piStartOffset = iStartOffset;
1.2          (shess    01-Sep-06):       *piEndOffset = c->iOffset;
1.1          (drh      31-Aug-06):       *piPosition = c->iToken++;
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06):       return SQLITE_OK;
1.1          (drh      31-Aug-06):     }
1.1          (drh      31-Aug-06):   }
1.1          (drh      31-Aug-06):   return SQLITE_DONE;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.3          (drh      02-Sep-06): static const sqlite3_tokenizer_module simpleTokenizerModule = {
1.1          (drh      31-Aug-06):   0,
1.1          (drh      31-Aug-06):   simpleCreate,
1.1          (drh      31-Aug-06):   simpleDestroy,
1.1          (drh      31-Aug-06):   simpleOpen,
1.1          (drh      31-Aug-06):   simpleClose,
1.1          (drh      31-Aug-06):   simpleNext,
1.1          (drh      31-Aug-06): };
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): void sqlite3Fts1SimpleTokenizerModule(
1.3          (drh      02-Sep-06):   sqlite3_tokenizer_module const**ppModule
1.1          (drh      31-Aug-06): ){
1.1          (drh      31-Aug-06):   *ppModule = &simpleTokenizerModule;
1.1          (drh      31-Aug-06): }
1.1          (drh      31-Aug-06): 
1.1          (drh      31-Aug-06): #endif /* !defined(SQLITE_CORE) || defined(SQLITE_ENABLE_FTS1) */
