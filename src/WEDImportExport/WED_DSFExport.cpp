/* 
 * Copyright (c) 2007, Laminar Research.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
 * THE SOFTWARE.
 *
 */

#include "WED_DSFExport.h"
#include "DSFLib.h"
#include "FileUtils.h"
#include "WED_Entity.h"
#include "PlatformUtils.h"
#include "GISUtils.h"
#include "CompGeomDefs2.h"
#include "WED_Group.h"
#include "WED_Version.h"
#include "WED_OverlayImage.h"
#include "WED_ToolUtils.h"
#include "WED_TextureNode.h"
#include "ILibrarian.h"

struct	DSF_ResourceTable {
	vector<string>		polygon_defs;
	map<string, int>	polygon_defs_idx;
	
	int accum_pol(const string& f)
	{
		map<string,int>::iterator i = polygon_defs_idx.find(f);
		if (i != polygon_defs_idx.end()) return i->second;
		polygon_defs.push_back(f);
		polygon_defs_idx[f] = polygon_defs.size()-1;
		return				  polygon_defs.size()-1;
	}
};

static void swap_suffix(string& f, const char * new_suffix)
{
	string::size_type p = f.find_last_of(".");
	if (p != f.npos) f.erase(p);
	f += new_suffix;
}

static void strip_path(string& f)
{
	string::size_type p = f.find_last_of(":\\/");
	if (p != f.npos) f.erase(0,p+1);
}

static void	DSF_ExportTileRecursive(WED_Thing * what, ILibrarian * pkg, const Bbox2& bounds, set<string>& io_resources, DSF_ResourceTable& io_table, const DSFCallbacks_t * cbs, void * writer)
{
	WED_OverlayImage * img;
	WED_Entity * ent = dynamic_cast<WED_Entity *>(what);
	if (!ent) return;
	if (ent->GetHidden()) return;
	
	
	if ((img = dynamic_cast<WED_OverlayImage *>(what)) != NULL)
	{
		string img_file, pol_file;
		img->GetImage(img_file);
		pol_file = img_file;
		swap_suffix(pol_file,".pol");
		strip_path(img_file);
		
		int pol_idx = io_table.accum_pol(pol_file);
		
		IGISPointSequence * oring = img->GetOuterRing();
		
		cbs->BeginPolygon_f(pol_idx, 65535, 4, writer);
		cbs->BeginPolygonWinding_f(writer);
		
		for (int pn = oring->GetNumPoints()-1; pn >= 0; --pn)
		{	
			WED_TextureNode * tn = dynamic_cast<WED_TextureNode *>(oring->GetNthPoint(pn));
			if (tn)
			{
				Point2 st, v;
				tn->GetTexCoord(st);	
				tn->GetLocation(v);
				double c[4] = { v.x, v.y, st.x, st.y };
				cbs->AddPolygonPoint_f(c, writer);
			}
		}
		
		cbs->EndPolygonWinding_f(writer);
		cbs->EndPolygon_f(writer);		
		
		if (io_resources.count(pol_file) == 0)
		{
			io_resources.insert(pol_file);
			string pol_path = pol_file;
			pkg->LookupPath(pol_path);
			if (!FILE_exists(pol_path.c_str()))
			{
				FILE * pfile = fopen(pol_path.c_str(), "w");
				if (pfile)
				{
					int is_apple = 1;
					#if IBM || LIN
						is_apple = 0;
					#endif
					fprintf(pfile, "%s" CRLF, is_apple ? "A" : "I"); 
					fprintf(pfile, "850" CRLF);
					fprintf(pfile, "DRAPED_POLYGON" CRLF CRLF);
					fprintf(pfile, "# Generated by WED " WED_VERSION_STRING CRLF);
					fprintf(pfile, "LAYER_GROUP airports -1" CRLF);
					fprintf(pfile, "TEXTURE_NOWRAP %s" CRLF, img_file.c_str());
					fprintf(pfile, "SCALE 25 25" CRLF);
					fclose(pfile);
				}
			}
		}
	}
	
	int cc = what->CountChildren();
	for (int c = 0; c < cc; ++c)
		DSF_ExportTileRecursive(what->GetNthChild(c), pkg, bounds, io_resources, io_table, cbs, writer);
}

static void DSF_ExportTile(WED_Group * base, ILibrarian * pkg, int x, int y, set<string>& io_resources)
{
	void *			writer;
	DSFCallbacks_t	cbs;
	char	prop_buf[256];
	
	writer = DSFCreateWriter(x,y,x+1,y+1, 8);
	DSFGetWriterCallbacks(&cbs);

	sprintf(prop_buf, "%d", (int) x  );		cbs.AcceptProperty_f("sim/west", prop_buf, writer);
	sprintf(prop_buf, "%d", (int) x+1);		cbs.AcceptProperty_f("sim/east", prop_buf, writer);
	sprintf(prop_buf, "%d", (int) y+1);		cbs.AcceptProperty_f("sim/north", prop_buf, writer);
	sprintf(prop_buf, "%d", (int) y  );		cbs.AcceptProperty_f("sim/south", prop_buf, writer);
	cbs.AcceptProperty_f("sim/planet", "earth", writer);
	cbs.AcceptProperty_f("sim/creation_agent", "WorldEditor" WED_VERSION_STRING, writer);
	cbs.AcceptProperty_f("laminar/internal_revision", "0", writer);
	cbs.AcceptProperty_f("sim/overlay", "1", writer);

	DSF_ResourceTable	rsrc;
	
	Bbox2	clip_bounds(x,y,x+1,y+1);
	DSF_ExportTileRecursive(base, pkg, clip_bounds, io_resources, rsrc, &cbs, writer);
	
	for(vector<string>::iterator s = rsrc.polygon_defs.begin(); s != rsrc.polygon_defs.end(); ++s)
		cbs.AcceptPolygonDef_f(s->c_str(), writer);

	char	rel_dir [512];
	char	rel_path[512];
	string full_dir, full_path;
	sprintf(rel_dir ,"Earth nav data" DIR_STR "%+03d%+04d",							  latlon_bucket(y), latlon_bucket(x)	  );
	sprintf(rel_path,"Earth nav data" DIR_STR "%+03d%+04d" DIR_STR "%+03d%+04d.dsf",  latlon_bucket(y), latlon_bucket(x), y, x);
	full_path = rel_path;
	full_dir  = rel_dir ;
	pkg->LookupPath(full_dir );
	pkg->LookupPath(full_path);
	FILE_make_dir_exist(full_dir.c_str());
	DSFWriteToFile(full_path.c_str(), writer);
	DSFDestroyWriter(writer);
}

void DSF_Export(WED_Group * base, ILibrarian * package)
{
	Bbox2	wrl_bounds;
	base->GetBounds(wrl_bounds);
	int tile_west  = floor(wrl_bounds.p1.x);
	int tile_east  = ceil (wrl_bounds.p2.x);
	int tile_south = floor(wrl_bounds.p1.y);
	int tile_north = ceil (wrl_bounds.p2.y);
	
	set<string>	generated_resources;
	
	for (int y = tile_south; y < tile_north; ++y)
	for (int x = tile_west ; x < tile_east ; ++x)
		DSF_ExportTile(base, package, x, y, generated_resources);	
}

int		WED_CanExportDSF(IResolver * resolver)
{
	return 1;
}

void	WED_DoExportDSF(IResolver * resolver)
{
	ILibrarian * l = WED_GetLibrarian(resolver);
	WED_Thing * w = WED_GetWorld(resolver);
	DSF_Export(dynamic_cast<WED_Group *>(w), l);
}

