/* 
 * Copyright (c) 2004, Laminar Research.
 *
 * Permission is hereby granted, free of charge, to any person obtaining a 
 * copy of this software and associated documentation files (the "Software"), 
 * to deal in the Software without restriction, including without limitation
 * the rights to use, copy, modify, merge, publish, distribute, sublicense, 
 * and/or sell copies of the Software, and to permit persons to whom the 
 * Software is furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in
 * all copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR 
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY, 
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE 
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER 
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, 
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN 
 * THE SOFTWARE.
 *
 */
#include "WED_Zoning.h"
#include "MapDefs.h"
#include "MapAlgs.h"
#include "CompGeom.h"

/*
 * ChopPolygonSide
 *
 * Given a (sometimes goofy) polygon, this routine cuts off one side to form a
 * quad that we can stuff buildings into.
 *
 * Pass in a polygon and the index number of the side, where the first side (index
 * 0) goes from point index 0 to point index 1 of the polygon.  (This is how we will
 * number all polygon edges.)
 *
 * The booleans return a few possible events: if a chop fully removes a side, this
 * is indicated.  If a chop creates a side, this is indicated too.  This will happen
 * when the turn on the polygon at that vertex is concave.
 *
 * The chopped polygon is always a quad, and the first side is always the original
 * side we were chopping from.  The remainder is the original polygon with the faces
 * adjusted as expected.
 *
 */
 
static	void	ChopPolygonSide(
						const Polygon_2&		inPolygon,
						int						inSide,
						double					inDistance,
						bool&					inSideAddedBefore,
						bool&					inSideAddedAfter,
						bool&					inSideRemovedBefore,
						bool&					inSideRemovedAfter,
						Polygon_2&				outChop,
						Polygon_2&				outRemainder)
{
	Polygon_2::Edge_const_circulator	theEdge = inPolygon.edges_circulator();
										theEdge += inSide;
	Polygon_2::Edge_const_circulator	prevEdge = theEdge;
										--prevEdge;
	Polygon_2::Edge_const_circulator	nextEdge = theEdge;
										++nextEdge;
	Polygon_2::Vertex_circulator		srcV = inPolygon.vertices_circulator();
										srcV += inSide;
	Polygon_2::Vertex_circulator		trgV = srcV;
										++trgV;
	Polygon_2::Vertex_circulator		prevV = srcV;
										--prevV;
	Polygon_2::Vertex_circulator		nextV = trgV;
										++nextV;
										
	// First form a "cutting slice, a line that divides the new and old polygon!
	Vector_2 inset = (*theEdge).to_vector().perpendicular(CGAL::COUNTERCLOCKWISE);	
	double	dstv = sqrt(CGAL::to_double(inset * inset));	
	Aff_transformation_2	transformer(CGAL::Translation(), inset * (inDistance / dstv));
	Line_2	original_line = (*theEdge).supporting_line();
	Line_2	cut_slice = original_line.transform(transformer);
	
	// Now we have to figure out what this does to our poor polygon.  There are a
	// few possibilities for the points just before and after us:
	// If the points are on the negative side of our line, that joint was concave...
	// we will intersect that side with us and introduce a new edge to the polygon
	// that will never get buildings...it is the area added to the polygon by cutting
	// into it.	
	// If the point is not on the negative side of the slice, then the slice 
	// fully eliminates the edge as it is cut away.
	// If the point is on the negative side of the sice but not on the positive side
	// of the original edge, then we are cutting away...intersect the edge with the 
	// slice to pull the point back.
	
	Point_2	prev_pt, next_pt;		// Points generated by intersections
	CGAL::Object	result;
	
	inSideRemovedBefore = inSideRemovedAfter = inSideAddedBefore = inSideAddedAfter = false;
	
	if (original_line.oriented_side(*prevV) != CGAL::ON_POSITIVE_SIDE)
	{
		// A side will be introduced before us by cutting away, because the joint
		// is concave or we have an antenna.
		inSideAddedBefore = true;
		result = CGAL::intersection(cut_slice, (*prevEdge).supporting_line());
		if (!CGAL::assign(prev_pt, result) || IsNearColinear(cut_slice.direction(), (*prevEdge).supporting_line().direction()))
		{	
			// We didn't intersect...probably an antenna.
			prev_pt = *srcV;
			prev_pt = prev_pt.transform(transformer);
		}
	} 
	else if (cut_slice.oriented_side(*prevV) == CGAL::ON_POSITIVE_SIDE) 
	{
		// A side will be reduced in size
		result = CGAL::intersection(cut_slice, (*prevEdge).supporting_line());
		if (!CGAL::assign(prev_pt, result) || IsNearColinear(cut_slice.direction(), (*prevEdge).supporting_line().direction()))
		{	
			inSideAddedBefore = true;
			prev_pt = *srcV;
			prev_pt = prev_pt.transform(transformer);
		}
	} 
	else 
	{
		// The previous side is being collapsed completey.
		if (IsNearColinear(cut_slice.direction(), (*prevEdge).supporting_line().direction()))
		{
			inSideAddedBefore = true;
			prev_pt = *srcV;
			prev_pt = prev_pt.transform(transformer);			
		} else
			inSideRemovedBefore = true;
	}
	
	if (original_line.oriented_side(*nextV) != CGAL::ON_POSITIVE_SIDE)
	{
		// A side will be introduced before us by cutting away.
		inSideAddedAfter = true;
		result = CGAL::intersection(cut_slice, (*nextEdge).supporting_line());
		if (!CGAL::assign(next_pt, result) || IsNearColinear(cut_slice.direction(), (*nextEdge).supporting_line().direction()))
		{	
			next_pt = *trgV;
			next_pt = next_pt.transform(transformer);
		}
	} 
	else if (cut_slice.oriented_side(*nextV) == CGAL::ON_POSITIVE_SIDE) 
	{
		// A side will be reduced in size
		result = CGAL::intersection(cut_slice, (*nextEdge).supporting_line());
		if (!CGAL::assign(next_pt, result) || IsNearColinear(cut_slice.direction(), (*nextEdge).supporting_line().direction()))
		{	
			inSideAddedAfter = true;
			next_pt = *trgV;
			next_pt = next_pt.transform(transformer);
		}
	} 
	else 
	{
		// The previous side is being collapsed complete.y
		if (IsNearColinear(cut_slice.direction(), (*nextEdge).supporting_line().direction()))
		{
			inSideAddedAfter = true;
			next_pt = *trgV;
			next_pt = next_pt.transform(transformer);
		} else 
			inSideRemovedAfter = true;
	}
	
	// Well that was exciting.  Now we're ready to build some polygons.  First
	// build the "cut polygon.  This will always be a quad EXCEPT when we cut the
	// side of a triangle to its max distance, in which case it will actually be
	// a triangle.  This case is detected because (1) We are eliminating both sides
	// and (2) the previous and next vertices are the same!  In this case we do
	// not push prev and next twice because that would form a zero-length side.
	
	outChop.push_back(*srcV);
	outChop.push_back(*trgV);
	if (inSideRemovedBefore && inSideRemovedAfter)
	{
		outChop.push_back(*nextV);
		if (nextV != prevV)
			outChop.push_back(*prevV);
	} else {
		if (inSideRemovedAfter)
			outChop.push_back(*nextV);
		else
			outChop.push_back(next_pt);
		if (inSideRemovedBefore)
			outChop.push_back(*prevV);
		else
			outChop.push_back(prev_pt);			
	}
	
	// Now let's do the remainder polygon.
	// Basically we sub in prev_pt or next_pt unless a side was removed.
	// If a side was added we leave the original point in.
	// If both sides were removed and we are a triangle, we are GONE!
	
	if (prevV != nextV || !inSideRemovedBefore || !inSideRemovedAfter)
	{
		Polygon_2::Vertex_circulator iter = inPolygon.vertices_circulator();
		Polygon_2::Vertex_circulator flag = inPolygon.vertices_circulator();
		
		do {
			if (iter == srcV)
			{
				if (inSideAddedBefore)					// This order might be surprising, but it makes sense.  If we are creating a new
					outRemainder.push_back(*iter);		// segment, the misnamed "prev_pt" is actually beyond the src pt on the old polygon
				if (!inSideRemovedBefore)				// and must be pushed second.  The same logic applies in inverse for the next_pt.
					outRemainder.push_back(prev_pt);
			} else if (iter == trgV) {
				if (!inSideRemovedAfter)
					outRemainder.push_back(next_pt);
				if (inSideAddedAfter)
					outRemainder.push_back(*iter);
			} 
			else  {
				outRemainder.push_back(*iter);
			}
			++iter;
		} while (iter != flag);
	}
}						

void	WED_BuildZoningBlocks(
						Pmwx::Face_handle		inBlock,
						const vector<double>&	inMinDepth,
						const vector<double>&	inMaxDepth,
						vector<double>&			outDepth,
						vector<Polygon_2>&		outBlocks,						
						vector<Polygon_2>&		outExtra)
{
	/* Convert the polygon to local cartesian coordinates. */
		Point_2		ref;
		Polygon_2	block;
		
	Pmwx::Ccb_halfedge_circulator e = inBlock->outer_ccb();
	Pmwx::Ccb_halfedge_circulator stop = e;
	do {
		block.push_back(e->source()->point());
		++e;
	} while (e != stop);
		
	ref = FindRefPoint(block.vertices_begin(), block.vertices_end());
	
	LatLonToLocalMeters(block.vertices_begin(), block.vertices_end(), ref);
	
	/* Inset the polygon to provide for the thickness of roads. */
		Polygon_2	block_no_roads;
		vector<double>	ratios(block.size(), 1.0);
	
		InsetPolygon(block, ratios, 4.0, true, block_no_roads);

	/* Order the sides based on dominating road type to build a working
	 * order for the sides.  Skip any side that we can't build on. */
	 
	/* For each side, attempt to build the zoning block. */
	for (int n = 0; n < block_no_roads.size(); ++n)
	{		
		/* Find the maximum we can inset this side.  Clamp our depth and
		 * pick an actual depth based on those numbers. */
		 
		 // HACK ALERT: When we have a slightly concave side and we are chopping it up, the next side
		 // after our first N unit cut will have a max length of slightly less than N.  This is because
		 // in the case of a slightly concave side we use a primitive insetting method since side intersection
		 // is degenerate.  So...as a hack for now we don't require as large of an inset as we will do.  This needs
		 // to be addressed in the future by finding the max inset and chopping it.
		 
		double inset = CalcMaxSideInset(block_no_roads, n);
		if (inset > 10.0)
		{
			/* Cut the polygon in half forming a zoning block and remainder.
			 * (We always expect a quad from this!) */
			Polygon_2 chop, remain;
			bool	addBefore, addAfter, removeBefore, removeAfter;
			
			ChopPolygonSide(block_no_roads, n, std::min(inset, 10.2), addBefore, addAfter, removeBefore, removeAfter, chop, remain);

			if (removeBefore) --n;
			if (addBefore) ++n;
			if (addAfter) ++n;
			block_no_roads = remain;
			outBlocks.push_back(chop);
//			outBlocks.push_back(remain);
//			break;
		}
	}
	outExtra.push_back(block_no_roads);	
//	outBlocks.push_back(block_no_roads);	
	
	/* Convert it all back to regular coordinates. */
	vector<Polygon_2>::iterator poly;
	for (poly = outBlocks.begin(); poly != outBlocks.end(); ++poly)
		LocalMetersToLatLon(poly->vertices_begin(), poly->vertices_end(), ref);
	for (poly = outExtra.begin(); poly != outExtra.end(); ++poly)
		LocalMetersToLatLon(poly->vertices_begin(), poly->vertices_end(), ref);
}

void	WED_PlaceBuildings(Pmwx::Face_handle	inBlock)
{
	vector<double>	mind, maxd, outd;
	vector<Polygon_2>	blocks, extra;

	WED_BuildZoningBlocks(inBlock, mind, maxd, outd, blocks, extra);
	
	GISPolyObjPlacementVector& v = inBlock->mPolyObjs;
	
	v.clear();
	for (vector<Polygon_2>::iterator poly = blocks.begin(); poly != blocks.end(); ++poly)
	{
		GISPolyObjPlacement_t	placement;
		placement.mRepType = 0;
		placement.mShape = *poly;
		placement.mHeight = 1.0;
		placement.mDerived = true;
		v.push_back(placement);
	}	
}
